# 자바의 동시성 프로그래밍 지원

## 첫 릴리즈 (1996)

- 스레드
- 동기화
- wait/notify

## 자바 5

- 동시성 컬렉션인 java.util.concurrent 라이브러리
- 실행자(Executor) 프레임 워크

## 자바 7

- 고성능 병렬 분해 프레임워크인 포크-조인 패키지

## 자바 8

- `parallel` 메서드
  - 파이프 라인을 병렬 실행할 수 있는 스트림

# 동시성에서 중요한 두가지

1. 안전성(Safety) 유지
2. 응답가능(liveness) 상태 유지

# parallel()

앞선 메르센 소수를 생성하는 프로그램(아이템 45)에 해당 메서드를 사용하면 아무것도 출력하지 못하고 CPU가 90%나 잡아먹는 상태가 무한히 계속된다.

### **이유는?**

스트림 라이브러리가 이 파이프라인을 병렬화 하는 방법을 찾지 못했기 때문이다.

**데이터 소스가 `Stream.iterate` 거나 중간 연산으로 `limit` 을 쓰면 파이프라인 병렬화로는 성능 개선을 기대할 수 없다.**

또한 파이프라인 병렬화는 limit을 다룰 때 CPU 코어가 남는다면 원소를 몇 개 더 처리한 후 제한 개수 이후의 결과를 버려도 아무런 해가 없다고 가정한다. (하지만 해당 소스는 원소 하나 계산하는 비용이 어마어마하다. 그리하여 기능 마비가 된다)

# 병렬에 효과적인 소스

- ArrayList
- HashMap
- HashSet
- ConcurrentHashMap
- 배열
- int 범위
- long 범위

## 왜?

- 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있어 다수에 스레드에 분배하기 좋다.
  - 나누는 작업은 Spliterator가 담당
  - Spliterator 객체는 Stream이나 Iterable의 `spliterator` 메서드로 얻어올 수 있다.
- 원소들을 순차적으로 실행할 때의 참조 지역성이 뛰어나다.
  - 이웃한 원소의 참조들이 메모리에 연속하여 저장되어 있다.
  - 참조 지역성이 낮으면 스레드는 데이터가 주 메모리에서 캐시메모리로 전송되어 오는 시간을 기다리게 된다.
  - 참조 지역성은 벌크 연산을 병렬화 할때 아주 중요하다.

# 병렬화에 효과적인 연산

- 축소 연산
  - 파이프 라인에서 만들어진 모든 원소를 하나로 합치는 작업
    - (ex) reduce, min, max, count, sum
- 조건에 맞으면 바로 반환되는 메서드
  - (ex) anyMatch, allMatch, noneMatch

## 예외

- 가변 축소를 수행하는 Stream의 collect 메서드는 병렬화에 적합하지 않다.
  - 컬렉션들을 합치는 부담이 크기 때문.

# 그래서

- **스트림을 잘못 병렬화 하면 성능이 나빠질 뿐만 아니라 결과 자체가 잘못되거나 예상못한 동작이 발생할 수 있다.**
  - (ex) 위 메르센 소수 프로그램은 혹시나 완료되더라도 출력 소수의 순서가 올바르지 않을 수 있다. 정렬하고 싶다면 종단연산 forEach를 forEachOrdered로 바꿔주자.
- **파이프라인이 수행하는 진짜 작업이 병렬화에 드는 추가 비용을 상쇄하지 못한다면 성능 향상은 미미하다.**
  - **_성능 향상 추정 방법: 스트림안의 원소수와 원소당 수행되는 코드 줄수를 곱해보자. 이 값이 최소 수십만은 되어야 성능 향상을 맛볼 수 있다._**
- 스트림 병렬화는 오직 성능 최적화 수단이다.
  - 병렬화를 사용할 가치가 있는지 확인하자 (아이템 67)
- 병렬화할 일은 누구에게나 적다.
  - 효과를 보는 경우가 그리 많지는 않다.
    - 대신 _조건이 잘 갖춰지면 parallel 메서드 호출 하나로 거의 프로세서 코어수에 비례하는 성능 향상이 가능하다._

# 병렬화가 효과를 발휘하는 예시

## n보다 작거나 같은 소수의 개수를 계산하는 함수

```java
static long pi(long n) {
        return LongStream.rangeClosed(2, n)
                .parallel() // 이친구가 있는거랑 없는거랑 3.37배나 차이가 난다.
                .mapToObj(BigInteger::valueOf)
                .filter(i -> i.isProbablePrime(50))
                .count();
    }
```

- 사실 n이 더 크다면 해당 방식보다는 ‘레머의 공식' 이라는 효율적인 알고리즘을 사용하자.

# 이외 팁

- 무작위 수들로 이뤄진 스트림을 병렬화 할땐 `ThreadLocalRandom` 대신 `SplittableRandom` 인스턴스를 이용하자.
  - SplittableRandom은 정확히 이럴 때 쓰고자 설계된 것이라 병렬화 시 성능이 선형으로 증가한다.
  - ThreadLocalRandom은 단일 스레드에서 쓰고자 만들었기 때문에 위에거 만큼 빠르지 않다.
  - 그냥 Random은 모든 연산을 동기화하기 때문에 병렬 처리시 최악의 성능을 보인다.

# 정리

- 올바른 계산, 확실히 성능이 빨라질 것이라는 확신 없이는 스트림 파이프라인 병렬화는 시도조차 하지말라.
- 잘못 병렬화하면 오동작, 성능 문제가 생긴다.
- 운영과 비슷한 환경에서 수행해보며 성능 지표를 유심히 관찰하고, 성능 상승이 확실할 때 운영 코드에 반영하라.
