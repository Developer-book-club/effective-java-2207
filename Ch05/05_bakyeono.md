# 5장 제네릭

* 자바 5부터 지원
* 컬렉션이 담을 수 있는 타입을 컴파일러가 검사할 수 있다.


## 아이템 26 로 타입은 사용하지 말라

* 제네릭 타입, 제네릭 클래스, 제네릭 인터페이스
	* 클래스와 인터페이스 선언에 타입 매개변수가 붙은 것.
	* 예: `List<E>`
* 매개변수화(parameterized type) 타입
	* 제네릭 타입에 매개변수로 실제 타입을 지정한 것
	* 예: `List<String>`
* 로(raw) 타입
	* 제네릭 타입을 정의하면 같이 정의된다.
	* 타입 매개변수를 사용하지 않은 제네릭 타입
	* 제네릭 도입 전의 코드와 호환하기 위한 궁여지책
	* 예: `List`
* 제네릭을 안 쓰면 컬렉션에서 타입 검사를 컴파일러가 하지 못한다. 런타임에 에러가 난다.
* 제네릭을 쓰면 타입 검사를 할 수 있다. 하지만 로 타입을 쓰면 타입 검사를 하지 못한다.
* 임의 객체 매개변수화 타입(`List<Object>`)과 로 타입(`List`)의 차이는?
	* `List`: 제네릭 기능을 쓰지 않겠다.
	* `List<Object>`: 제네릭 기능을 쓰되,  모든 타입을 허용하겠다.
* 비한정적 와일드카드 타입(unbounded wildcard type)
	* 제네릭을 쓰되, 타입 매개변수가 무엇인지 신경쓰고 싶지 않은 경우
	* `Set<?>`와 같이 `?` 사용
* 예외: 로 타입을 써야 하는 경우
	* class 리터럴: class 리터럴에 매개변수화 타입을 사용하지 못하기 때문
	* instanceof 연산자: 런타임에 제네릭 타입 정보가 지워지기 때문
* 핵심 정리: 로 타입을 사용하면 런타임에 예외가 일어날 수 있으니 사용하면 안 된다. 로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐이다. 빠르게 훑어보자면, `Set<Object>`는 어떤 타입의 객체도 저장할 수 있는 매개변수화 타입이고, `Set<?>`는 모종의 타입 객체만 저장할 수 있는 와일드카드 타입이다. 그리고 이들의 로 타입인 `Set`은 제네릭 타입 시스템에 속하지 않는다. `Set<Object>`와 `Set<?>`는 안전하지만, 로 타입인 `Set`은 안전하지 않다.


## 아이템 27 비검사 경고를 제거하라

* 제네릭을 사용할 때, 컴파일러의 경고에 따라 코드를 수정해라.
	* 자바 7 이상에서 지원하는 다이아몬드 연산자(`<>`)를 사용해서 자동 추론하게 해도 된다.
* 모든 경고를 해결하여 타입 안정성을 확보해라.
* 타입 안전하다는 것을 확신한다면 `@SuppressWarning("unchecked")`를 해도 된다.
	* 정말 확신할 때만 그렇게 해라.
	* 최대한 좁은 영역에 한정해라.
	* 경고를 무시해도 되는 이유를 주석으로 남겨라.
* 핵심 정리 비검사 경고는 중요하니 무시하지 말자. 모든 비검사 경고는 런타임에 `ClassCastException`을 일으킬 수 있는 잠재적 가능성을 뜻하니 최선을 다해 제거하라. 경고를 없앨 방법을 찾지 못하겠다면, 그 코드가 타입 안전함을 증명하고 가능한 한 범위를 좁혀 `SuppressWarnings("unchecked")` 애너테이션으로 경고를 숨겨라. 그런 다음 경고를 숨기기로 한 근거를 주석으로 남겨라.



## 아이템 28 배열보다는 리스트를 사용하라

* 배열과 리스트의 차이
	* 배열은 공변(covariant): `Super[]` 는 `Sub[]` 의 상위 타입이 된다.
	* 리스트는 불공변(invariant): `List<Super>` 는 `List<Sub>`의 상위 타입이 되지 않는다.
* 배열의 공변성이 문제가 되는 경우
	* Long에 String을 넣는 경우, 런타임에 오류를 알게 된다.
	* 배열은 실체화(reify)되기 때문에 런타임에 원소의 타입을 알고 확인한다. 반면 제네릭은 타입 정보를 런타임에 알지 않는다.
* 배열과 제네릭은 잘 어우러지지 못한다.
	* 배열을 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없다.
	* `new List<E>[]`, `new List<String>[]`, `new E[]` 식으로 작성하면 컴파일할 때 제네릭 배열 생성 오류가 발생한다.
* 배열을 사용할 수 없는 경우, 대부분 리스트를 사용하면 해결된다.
* 핵심 정리 배열과 제네릭에는 매우 다른 타입 규칙이 적용된다. 배열은 공변이고 실체화되는 반면, 제네릭은 불공변이고 타입 정보가 소거된다. 그 결과 배열은 런타임에는 타입 안전하지만 컴파일타임에는 그렇지 않다. 제네릭은 반대다. 그래서 둘을 섞어 쓰기란 쉽지 않다. 둘을 섞어 쓰다가 컴파일 오류나 경고를 만나면, 가장 먼저 배열을 리스트로 대체하는 방법을 적용해보자.


## 아이템 29 이왕이면 제네릭 타입으로 만들라

* 일반 클래스를 제네릭 클래스로 바꾸기
	1. 클래스 선언에 타입 매개변수를 추가한다. `Stack<E>`
	2. 실체화 불가 타입의 배열 때문에 오류가 발생하는 경우
		* 방법 1: Object 배열을 생성하고 제네릭 배열로 형 변환한다.
		* 방법 2: 원소 필드의 타입을 `E[]`에서 `Object[]`로 바꾼다.
		* 배열 대신 리스트를 사용하는 것도 방법이지만, 항상 가능하거나 더 좋은 것은 아니다.
* 핵심 정리: 클라이언트에서 직접 형변환해야 하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편하다. 그러니 새로운 타입을 설계할 때는 형변환 없이도 사용할 수 있도록 하라. 그렇게 하려면 제네릭 타입으로 만들어야 할 경우가 많다. 기존 타입 중 제네릭이었어야 하는 게 있다면 제네릭 타입으로 변경하자. 기존 클라이언트에는 아무 영향을 주지 않으면서, 새로운 사용자를 훨씬 편하게 해주는 길이다(아이템 26).

## 아이템 30 이왕이면 제네릭 메서드로 만들라

* 클래스뿐 아니라, 메서드도 제너릭으로 만들 수 있다.
	* 예: Collections 의 binarySearch, sort 등
* 로 타입을 이용해 만들면 안 된다. (당연)
* 제네릭 싱글턴 팩터리
	* 불변 객체를 여러 타입으로 활용할 수 있게 만들어야 하는 경우
	* 요청한 타입 매개변수에 맞게 객체의 타입을 바꿔주는 정적 팩터리
* 재귀적 타입 한정(recursive type bound)
	* 자기 자신이 들어간 식을 사용해 타입 매개변수의 허용 범위를 한정
	* 주로 Comparable 인터페이스와 함께 사용된다.
	* `public static <E extends Comparable<E>> E max(Collection<E> c);`
		* 모든 타입 E는 자신과 비교할 수 있다.
* 핵심 정리: 제네릭 타입과 마찬가지로, 클라이언트에서 입력 매개변수와 반환값을 명시적으로 형변환해야 하는 메서드보다 제네릭 메서드가 더 안전하며 사용하기도 쉽다. 타입과 마찬가지로, 메서드도 형변환 없이 사용할 수 있는 편이 좋으며, 많은 경우 그렇게 하려면 제네릭 메서드가 되어야 한다. 역시 타입과 마찬가지로, 형변환을 해줘야 하는 기존 메서드는 제네릭하게 만들자. 기존 클라이언트는 그대로 둔 채 새로운 사용자의 삶을 훨씬 편하게 만들어줄 것이다(아이템 26).

## 아이템 31 한정적 와일드카드를 사용해 API 유연성을 높이라

* 매개변수화 타입은 불공변인 것이 더 적절하다.
	* 리스코프 치환 원칙을 위배하기 때문이다.
	* `List<Object>` 는 아무거나 넣을 수 있지만 `List<String>`은 아님.
* 한정적 와일드카드 타입
	* 불공변성 때문에 문제가 되는 경우, 하위 타입, 상위 타입을 사용할 수 있도록 지원하는 문법
	* `Iterable<? extends E>`: E의 하위 타입의 이터러블을 의미 (생산자 입장)
	* `Collection<? super E>`:  E의 상위 타입의 컬렉션을 의미 (소비자 입장)
* 유연성을 극대화하려면 원소의 생산자나 소비자용 입력 매개변수에 와일드카드 타입을 사용하라.
	* 단, 입력 매개변수가 생산자와 소비자 역할을 동시에 한다면 와일드카드 타입을 써도 좋을 게 없다.
* PECS: producer-extends, consumer-super (겟 앤 풋 원칙)
* 반환 타입에는 한정적 와일드카드 타입을 사용하면 안 된다.
	* 안 그러면 클라이언트 코드도 와일드카드 타입을 써야 된다.
	* 제대로 만들었다면, 클래스를 사용하는 사람은 와일드카드에 대해 신경쓰지 않아도 된다.
* 핵심 정리: 조금 복잡하더라도 와일드카드 타입을 적용하면 API가 훨씬 유연해진다. 그러니 널리 쓰일 라이브러리를 작성한다면 반드시 와일드카드 타입을 적절히 사용해줘야 한다. PECS 공식을 기억하자. 즉, 생산자는 extends를 소비자는 super를 사용한다. Comparable과 Comparator는 모두 소비자라는 사실도 잊지 말자.

## 아이템 32 제네릭과 가변인수를 함께 쓸 때는 신중하라

* 가변인수(varargs) 메서드와 제네릭은 잘 어울리지 못한다.
* 경고 문제
	* 가변인수 메서드를 호출하면 인수 배열이 자동 생성되는데 구현 방식의 문제로 인해 이 배열이 클라이언트에 노출된다.
	* 그 결과, varargs 매개변수에 제네릭이나 매개변수화 타입이 포함되면 까다로운 컴파일 경고가 발생한다.
	* 실체화 불가 타입은 런타임에 타입 정보를 적게 가진다. 실체화 불가 타입으로 varargs 변수를 선언하면 컴파일러가 경고를 낸다.
* 힙 오염 문제
	* 매개변수화 타입의 변수가 타입 다른 객체를 참조하면 힙 오염이 발생한다.
	* 다른 타입 객체를 참조하면 컴파일러가 자동 생성한 형변환이 실패할 수 있다.
	* 제네릭 타입 안정성이 깨진다.
* 제네릭 varargs 매개변수를 받는 메서드를 선언할 수 있게 한 이유는 무엇일까?
	* 제네릭이나 매개변수화 타입의 varargs 매개변수를 받는 메서드가 실무에서 매우 유용하기 때문이다.
	* 예:
		* `Arrays.asList(T... a)`
		* `Collections.addAll(Collection<? super T> c, T... elements)`
		* `EnumSet.of(E first, E... rest)`
* 자바 7에서 추가된 `@SafeVarargs` 어노테이션을 이용해 경고를 숨길 수 있다.
	* 제네릭이나 매개변수화 타입의 varargs 매개변수를 받는 모든 메서드에 @Safe Varargs를 달아라. 그래야 사용자가 혼란을 느끼지 않는다.
	* 단, 안전하다고 확인된 것에 한해야 한다.
		* varargs 매개변수 배열에 아무것도 저장하지 않는다.
		* 그 배열(혹은 복제본)을 신뢰할 수 없는 코드에 노출하지 않는다.
* varargs 매개변수를 List 매개변수로 바꾸는 것도 좋은 방법이다. (아이템 28)
* 핵심 정리: 가변인수와 제네릭은 궁합이 좋지 않다. 가변인수 기능은 배열을 노출하여 추상화가 완벽하지 못하고, 배열과 제네릭의 타입 규칙이 서로 다르기 때문이다. 제네릭 varargs 매개변수는 타입 안전하지는 않지만, 허용된다. 메서드에 제네릭 (혹은 매개변수화된) varargs 매개변수를 사용하고자 한다면, 먼저 그 메서드가 타입 안전한지 확인한 다음 @SafeVarargs 애너테이션을 달아 사용하는 데 불편함이 없게끔 하자.

## 아이템 33 타입 안전 이종 컨테이너를 고려하라

* 타입 안전 이종 컨테이너 패턴(type safe heterogeneous container pattern)
	* 컨테이너 대신 키를 매개변수화
	* 컨테이너에 값을 넣거나 뺄 때 매개변수화한 키를 함께 제공
* 타입 토큰(type token): 컴파일타임 타입 정보와 런타임 타입 정보를 알아내기 위해 메서드들이 주고받는 class 리터럴
* 예: `Favorite` 클래스
	* 타입별로 인스턴스를 저장하고 검색
	* 각 타입의 Class 객체를 매개변수화한 키 역할로 사용
	* 구현
		* `Map<Class<?>, Object> favorites`
	* 동작 원리
		* class의 클래스가 제네릭이기 때문
		* class 리터럴의 타입은 `Class`가 아닌 `Class<T>`
			* `String.class`의 타입: `Class<String>`
			* `Integer.class`의 타입: `Class<Integer>`
	* 제약 1: 악의적인 클라이언트가 Class 객체를 (제네릭이 아닌) 로 타입(아이템 26)으로 넘기면 Favorites 인스턴스의 타입 안전성이 쉽게 깨진다.
		* 내부에서 인스턴스의 타입을 검사하는 것으로 해결 가능하다.
			* java.util.Collections 의 checkedSet, checkedList, checkedMap 컬렉션 래퍼들이 그런 방식이다.
	* 제약 2: 실체화 불가 타입(아이템 28)에는 사용할 수 없다.
		* `String`, `String[]`은 저장할 수 있어도 `List<String>`은 저장할 수 없다.
* 핵심 정리: 컬렉션 API로 대표되는 일반적인 제네릭 형태에서는 한 컨테이너가 다룰 수 있는 타입 매개변수의 수가 고정되어 있다. 하지만 컨테이너 자체가 아닌 키를 타입 매개변수로 바꾸면 이런 제약이 없는 타입 안전 이종 컨테이너를 만들 수 있다. 타입 안전 이종 컨테이너는 Class를 키로 쓰며, 이런 식으로 쓰이는 Class 객체를 타입 토큰이라 한다. 또한, 직접 구현한 키 타입도 쓸 수 있다. 예컨대 데이터베이스의 행(컨테이너)을 표현한 DatabaseRow 타입에는 제네릭 타입인 `Column<T>`를 키로 사용할 수 있다.

