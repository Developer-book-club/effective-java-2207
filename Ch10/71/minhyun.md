검사예외는 발생한 문제를 프로그래머가 처리하여 안전성을 높이게 해준다.

어떤 메서드가 검사 예외를 던질 수 있다고 선언됐다면 이를 호출하는 코드에선 catch블록을 두어 예외를 붙잡아 처리하거나, 더 바깥으로 던져 문제를 전파해야 한다.

# 검사예외가 하나뿐일땐 고민하자 (생각도 못함..)

메서드가 단 하나의 검사 예외만 던질 때 오직 그 예외때문에 API 사용자는 try 블록을 추가해야하고 스트림에서 직접 사용하지 못하게 된다.

이럴땐 검사 예외를 안던지는 방법이 없는지 고민하자.

# 검사예외를 회피하는 방법

## 적절한 결과 타입을 담은 옵셔널을 반환

- 단점은 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다.
- 예외를 사용하면 구체적인 예외 타입과 해당 타입이 제공하는 메서드들을 활용해 부가 정보를 제공할 수 있다.

## 메서드를 쪼개기

검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꾼다.

```java
//기존
try {
	obj.action(args);
} catch (The CheckedException e) {
	... // 예외상황에 대처
}

//2개로 쪼개 리팩터링
if(obj.actionPermitted(args)) {
	obj.action(args);
} else {
	... //예외 상황에 대처
}
```

리팩터링 후 API가 더 아름답진 않지만 확실히 더 유연하긴 한다.

대신 actionPermitted() 는 상태 검사 메서드에 해당하여 여러 스레드가 동시에 접근하거나 외부 요인에 의해 상태가 변할 수 있다면 해당 리팩터링은 적절하지 않다.

# 정리

- 꼭 필요한 곳에만 사용한다면 검사예외는 프로그램의 안전성을 높여주지만 남용하면 쓰기 고통스러운 API를 낳는다.
- API호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자.