# 아이템 69: 예외는 진짜 예외 상황에만 사용하라

- 예외는 예외 상황에서만 사용되어야 하며 일상적인 제어 흐름용으로 사용되어서는 안 됨
- 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없어야 함
  - 특정 상태에서만 호출할 수 있는 상태 의존적 메서드를 제공하는 클래스는 상태 검사 메서드도 함께 제공해야 함
  - ex) Iterator 인터페이스의 next: 상태 의존적 메서드
  - ex) Iterator 인터페이스의 hasNext: 상태 검사 메서드
    - hasNext가 없었다면 반복문에 예외를 사용하게 되어 성능 저하 등 여러 문제가 발생함
    - 상태 검사 메서드를 사용하는 대신 빈 옵셔널, null 같은 특수한 값을 반환할 수도 있음(올바르지 않은 상태일 때) 

### 상태 검사 메서드 vs 옵셔널, 특정 값 
1. 옵셔널이나 특정 값 사용 
    - 외부 동기화 없이 여러 스레드가 동시 접근할 수 있거나 외부 요인으로 상태가 변할 수 있는 경우
      - 상태 검사 메서드와 상태 의존적 메서드의 호출 사이에 객체의 상태가 변할 수 있기 때문
    - 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행하는 경우
2. 상태 검사 메서드 방식 사용
    - 그 외 모든 경우 
      - 가독성이 낫고 잘못 사용했을 때 발견하기가 쉬움
      - 상태 검사 메서드 호출을 잊었다면 상태 의존적 메서드가 예외를 던져 버그를 확실히 찾을 수 있음 
      - but, 특정 값은 검사하지 않고 지나쳐도 발견하기가 어려움 (옵셔널은 예외)

<br><br>

# 아이템 70: 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

- 자바에서 문제 상황을 알리는 타입(throwable)
    - 검사 예외
      - 복구가 가능한 경우
    - 비검사 예외(런타임 예외, 에러)
      - 프로그래밍 오류를 나타내는 경우(프로그램에서 잡을 필요가 없거나 잡아서 처리해도 득보다는 실이 많은 경우)
      - 복구가 불가능한 경우
      - 복구할 수 있는 상황인지 프로그래밍 오류인지 명확하지 않은 경우 

### 예외 사용 규칙 
1. 호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용
    - 검사 예외와 비검사 예외를 구분하는 기본 규칙
    - 검사 예외를 던지면 호출자가 그 예외를 catch로 잡아 처리하거나 더 바깥으로 전파하도록 강제하게 됨
    - 메서드 선언에 포함된 검사 예외는 그 메서드를 호출했을 때 발생할 수 있는 유력한 결과임을 API 사용자에게 알려주는 것
    - 호출자가 예외 상황에서 벗어나는 데 필요한 정보를 알려주는 메서드를 함께 제공해야 함
2. 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용 
    - 런타임 예외의 대부분은 전제조건을 만족하지 못했을 때(클라이언트가 해당 API 명세에 기록된 제약을 지키지 못했을 때) 발생
      - ex) ArrayIndexOutOfBoundsException: 배열의 인덱스는 0과 '배열크기 - 1'여야 한다는 전제조건이 지켜지지 않았을 때 발생
3. 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 함
    - Error 클래스를 상속하면 안 됨
      - 에러: JVM이 자원 부족, 불변식 깨짐 등으로 더 이상 수행을 계속할 수 없을 때 사용 
    - throw 문으로 직접 던져도 안 됨
4. Exception, RuntimeException, Error를 상속하지 않는 throwable 구현은 지양할 것 
    - 정상적인 검사 예외보다 나은 점이 없으며 API 사용자를 헷갈리게 함

<br><br>

# 아이템 71: 필요 없는 검사 예외 사용은 피하라
- 검사 예외는 발생한 문제를 개발자가 처리하여 안전성을 높일 수 있게 해주지만 과하게 사용하는 경우 API 사용을 불편하게 함
  - 검사 예외가 포함된 메서드를 호출하는 코드에서는 catch 블록으로 그 예외를 붙잡아 처리하거나 더 바깥으로 던져야 함 -> API 사용자에게 부담을 줌
  - 검사 예외를 던지는 메서드는 스트림 안에서 직접 사용할 수 없음(자바 8~)
  - API를 제대로 사용해도 발생할 수 있는 예외이거나, 개발자가 의미 있는 조치를 취할 수 있는 경우 -> 검사 예외 / 그렇지 않은 경우 -> 비검사 예외

### 검사 예외를 회피하는 방법
- 단 하나의 검사 예외를 던지는 경우 API 사용자가 오직 그 예외 때문에 try 블록을 추가해야 하고, 스트림에서 사용하지 못하게 됨 -> 검사 예외를 안 던지는 방법을 고민해봐야 함

1. 적절한 결과 타입을 담은 옵셔널 반환  
    - 검사 예외 대신 빈 옵셔널을 반환
    - 단점: 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없음 
2. 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꾸기
    - 예외가 던져질지 여부를 boolean 값으로 반환
    - 예외를 유연하게 처리할 수 있음
```java
// 검사 예외를 던지는 메서드 (리팩터링 전)
try {
    obj.action(args);
} catch (TheCheckedException e) {
    // 예외 상황에 대처
}

// 상태 검사 메서드와 비검사 예외를 던지는 메서드 (리팩터링 후)
if (obj.actionPermitted(args)) {
    obj.action(args);
} else {
    // 예외 상황에 대처
}
```
- 상태 검사 메서드(actionPermitted)
  - 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인에 의해 상태가 변할 수 있다면 적절하지 않은 리팩터링 -> actionPermitted와 action 호출 사이에 객체의 상태가 변할 수 있기 때문 
  - actionPermitted가 action 메서드의 작업 일부를 중복 수행한다면 성능에서 손해이므로 적절하지 않은 리팩터링

<br><br>

# 아이템 72: 표준 예외를 사용하라
- 표준 예외를 재사용하는 것이 좋음
  - 다른 사람이 읽고 사용하기 쉬워짐
  - 예외 클래스 수가 적을수록 메모리 사용량도 줄고 클래스 적재 시간도 적게 걸림

### 재사용되는 주요 예외
1. IllegalArgumentException
    - 호출자가 인수로 부적절한 값을 넘길 때 던짐
    - ex) 반복 횟수를 지정하는 매개변수에 음수를 건넬 때
2. IllegalStateException
    - 대상 객체의 상태가 호출된 메서드를 수행하기에 적합하지 않을 때 던짐
    - ex) 제대로 초기화되지 않은 객체를 사용하려 할 때
3. NullPointerException
    - null을 허용하지 않는 메서드에 null을 건넸을 때 던짐
4. IndexOutOfBoundsException
    - 인덱스가 범위를 넘어섰을 때 던짐
5. ConcurrentModificationException
    - 허용하지 않는 동시 수정(ex. 단일 스레드에서 사용하려고 설계한 객체를 여러 스레드가 동시에 수정하려 할 때)이 발견됐을 때 던짐
6. UnsupportedOpertionException
    - 클라이언트가 요청한 동작을 대상 객체가 지원하지 않을 때 던짐 
    - ex) List 구현채에 remove 메서드를 호출할 때 

### 직접 재사용하면 안되는 예외
- Exception, RuntimeException, Throwable, Error는 직접 재사용하지 말 것
  - 여러 예외들을 포괄하는 상위 클래스, 추상 클래스이므로 안정적으로 테스트할 수 없음

### 표준 예외 사용 시 주의사항
- 더 많은 정보를 제공하기 원하는 경우 표준 예외를 확장해도 좋음
  - but, 예외는 직렬화할 수 있고 직렬화에는 많은 부담이 따르므로 특수한 예외를 새로 만드는 것은 지양할 것
- 인수 값이 무엇이든 어차피 실패할 경우에는 IllegalStateException를, 그렇지 않으면 IllegalArgumentException를 던질 것

<br><br>

# 아이템 73: 추상화 수준에 맞는 예외를 던지라
```java
//예외 번역
try {
    // 저수준 추상화를 이용한다.
} catch (LowerLevelException e) {
    // 추상화 수준에 맞게 번역한다.
    throw new HigherLevelException(...);
}
```
- 예외 번역: 상위 계층에서 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던지는 것 
```java
//예외 연쇄
try {
    // 저수준 추상화를 이용한다.
} catch (LowerLevelException cause) {
    // 저수준 예외를 고수준 예외에 실어 보낸다.
    throw new HigherLevelException(cause);
}
```
- 예외 연쇄: 문제의 근본 원인인 저수준 예외를 고수준 예외에 실어 보내는 방식
  - 예외 번역 시 저수준 예외가 디버깅에 도움이 된다면 예외 연쇄를 사용하는 것이 좋음
  - 별도의 접근자 메서드(Throwable의 getCause 메서드)를 통해 저수준 예외를 꺼내 볼 수 있음  
  - 예외 연쇄용 생성자를 통해 예외 연쇄용으로 설계된 상위 클래스 생성자에 원인을 건네주고, 최종적으로는 Throwable 생성자까지 건너가게 됨 

### 주의사항
- 무턱대고 예외를 전파하는 것보다는 예외 번역이 나은 방법이지만 남용해서는 안 됨
  - 가능하다면 저수준 메서드가 반드시 성공하도록 하고 저수준에서 예외가 발생하지 않도록 하는 것이 최선
    - 상위 계층 메서드의 매개변수 값을 미리 검사해서 아래 계층 메서드로 건네는 것도 방법임
- 아래 계층에서의 예외를 피할 수 없다면 상위 계층에서 그 예외를 처리하여 API 호출자에게까지 문제가 전파되지 않도록 할 것
  - 발생된 예외는 로깅 기능을 활용해 기록해둘 것 -> 사용자에게 문제를 전파하지 않으면서 개발자는 로그를 분석할 수 있음

<br><br>

# 아이템 74: 메서드가 던지는 모든 예외를 문서화하라

- 메서드가 던지는 예외는 그 메서드를 올바로 사용하는 데 중요한 정보 -> 예외 하나하나를 문서화하는 데 충분한 시간을 투자해야 함

### 예외 문서화 원칙 
1. 검사 예외는 메서드 선언의 throws 문에 일일이 선언할 것 (각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 문서화할 것)
    - 검사 예외를 공통 상위 클래스로 뭉뚱그려 선언하지 말 것 ex) Exception, Throwable을 던진다고 선언
      - cf) main 메서드: 오직 JVM만이 호출할 수 있는 메서드로 Exception을 던지도록 선언해도 괜찮음 
2. 비검사 예외도 검사 예외처럼 문서화해둘 것을 권장 
    - 해당 오류가 발생하지 않도록 코딩할 수 있음 
    - 비검사 예외를 문서화하는 일은 인터페이스 메서드에서 특히 중요함 -> 인터페이스의 일반 규약에 속하게 되어 그 인터페이스를 구현한 모든 구현체가 일관되게 동작할 수 있게 해줌
    - but, 비검사 예외를 모두 문서화하는 것은 현실적으로 불가능 -> 클래스를 수정하면서 새로운 비검사 예외를 던져도 호환성이 유지되기 때문   
3. 비검사 예외는 메서드 선언의 throws 문에는 넣지 말 것
    - 자바독 유틸리티는 메서드 선언의 throws 절에 등장하고, 메서드 주석의 @throws 태그에도 명시된 예외와 @throws 태그에만 명시된 예외를 시각적으로 구분해줌 
4. 한 클래스에 정의된 많은 메서드가 같은 이유로 같은 예외를 던진다면 그 예외를 클래스 설명에 추가할 것 
    - ex) NullPointerException 

<br><br>

# 아이템 75: 예외의 상세 메시지에 실패 관련 정보를 담으라

- 예외를 잡지 못해 프로그램이 실패하면 자바 시스템은 그 예외의 스택 추적 정보를 자동으로 출력함
  - 스택 추적: 예외 객체의 toString 메서드를 호출해 얻는 문자열, 보통은 예외의 클래스 이름 + 상세 메시지
    - 사후 분석을 위해 toString 메서드의 상세 메시지에 실패 원인에 관한 정보를 가능한 한 많이 담아 반환해야 함 (비밀번호, 암호 키 같은 보안과 관련된 정보 제외)

### 상세 메시지 정보 
1. 발생한 예외에 관여된 모든 매개변수와 필드의 값을 실패 메시지에 담아야 함
    - ex) IndexOutOfBoundsException의 상세 메시지: 범위의 최솟값과 최댓값, 범위를 벗어난 인덱스의 값
    - but, 문서와 소스코드에서 얻을 수 있는 정보까지 장황하게 담을 필요는 없음
2. 예외의 상세 메시지와 최종 사용자에게 보여줄 오류 메시지를 혼동해서는 안 됨
    - 예외 메시지는 가독성보다는 담긴 내용이 더 중요
3. 필요한 정보를 예외 생성자에서 모두 받아서 상세 메시지를 미리 생성해놓는 방법도 권장됨

<br><br>

# 아이템 76: 가능한 한 실패 원자적으로 만들라

- 실패 원자적: 호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지하는 특성

### 메서드를 실패 원자적으로 만드는 방법
1. 불변 객체로 설계
    - 불변 객체는 태생적으로 실패 원자적 -> 불변 객체의 상태는 생성 시점에 고정되어 절대 변하지 않기 때문
2. 작업 수행 전 매개변수의 유효성 검사 
    - 가변 객체의 메서드를 실패 원자적으로 만드는 가장 흔한 방법
    - 객체의 내부 상태를 변경하기 전 잠재적 예외의 가능성 대부분을 걸러낼 수 있는 방법
3. 실패할 가능성이 있는 코드를 객체의 상태를 바꾸는 코드보다 앞에 배치 
    - 계산을 수행해보기 전에 인수의 유효성을 검사해볼 수 없을 때 사용
    - ex) TreeMap: 잘못된 타입의 원소를 추가하려고 하면 트리를 변경하기 전, 해당 원소가 들어갈 위치를 찾는 과정에서 ClassCastException을 던짐
4. 객체의 임시 복사본에서 작업을 수행한 후, 작업이 성공적으로 완료되면 원래 객체와 교체
    - 데이터를 임시 자료구조에 저장해 작업하는 게 더 빠를 때 적용
    - ex) 정렬 메서드에서 정렬을 수행하기 전 입력 리스트의 원소들을 배열로 옮겨 담음
      - 반복문에서 원소들에 빠르게 접근할 수 있을뿐만 아니라 정렬에 실패하더라도 입력 리스트는 변하지 않는 효과를 얻게 됨
5. 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌림
    - 주로 디스크 기반의 내구성을 보장해야 하는 자료구조에 쓰임, 자주 쓰이는 방법은 아님

### 실패 원자성이 지켜지지 않는 경우
- 실패 원자성은 항상 달성할 수 있는 것은 아님 
  - ex) 두 스레드가 동기화 없이 같은 객체를 동시에 수정한다면 그 객체의 일관성이 깨질 수 있음 -> ConcurrentModificationException을 잡아냈다고 그 객체가 여전히 사용할 수 있는 상태라고 가정해서는 안 됨
  - Error는 복구할 수 없으므로 AssertionError에 대해 실패 원자적으로 만들려는 시도조차 할 필요가 없음
- 실패 원자성을 달성하기 위한 비용, 복잡도가 크면 실패 원자성을 지킬 수 없음
  - 실패 원자성을 지키지 못하면 실패 시의 객체 상태를 API 설명에 명시해야 함

<br><br>

# 아이템 77: 예외를 무시하지 말라
- 메서드 선언에 명시된 예외: 그 메서드를 사용할 때 적절한 조치를 취해달라는 뜻 
1. catch 블록을 비우지 말 것 
    - catch 블록을 비워두면 예외가 존재할 이유가 없음 
2. 예외를 무시해야 한다면 catch 블록을 비우기로 한 이유를 주석으로 남기고 예외 변수의 이름을 ignored로 바꿀 것
    - ex) FileInputStream을 닫을 때
      - 입력 전용 스트림이므로 파일의 상태를 변경하지 않았으니 복구할 것이 없으며, 스트림을 닫는다는 건 필요한 정보는 이미 다 읽었다는 뜻이니 남은 작업을 중단할 이유도 없음 
