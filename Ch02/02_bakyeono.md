# 2장 객체 생성과 파괴

## 아이템 1 생성자 대신에 정적 팩터리 메서드를 고려하라

* 인스턴스 생성 수단: public 생성자, 정적 팩터리 메서드
* 정적 팩터리 메서드: 그냥 인스턴스를 반환하는 정적 메서드
* 장점 1: 이름을 가질 수 있다.
* 장점 2: 반드시 인스턴스를 새로 만들지 않아도 된다.
* 장점 3: 반환 타입의 하위 타입의 객체를 반환할 수 있다.
* 장점 4: 인자에 따라 다른 하위 타입의 객체를 반환할 수 있다.
* 장점 5: 정적 팩터리 메서드를 정의하는 시점에, 반환할 객체의 클래스가 정의되지 않아도 된다.
* 단점 1: 정적 팩터리 메서드만으로는 하위 클래스를 만들 수 없다. 상속을 하려면 public-protected 생성자가 필요하다.
* 단점 2: 정적 팩터리 메서드를 찾기 어렵다. 그래서 명명 관례를 사용한다.
* 명명 관례
	* from: 인자 하나를 형 변환
	* of: 인자를 모아 적합한 인스턴스 반환
	* valueOf: from, of의 더 자세한 버전
	* instance, getInstance: 인자로 지정한 인스턴스 반환
	* create, newInstance: 새 인스턴스 생성
	* getType: 다른 클래스에 팩터리 메서드를 정의할 때 사용 `A.getB()`
	* newType: 다른 클래스에 팩터리 메서드를 정의할 때 사용 `A.newB()`
	* type: getType, newType 의 간결한 버전
* 핵심 요약: 정적 팩터리 메서드와 public 생성자는 각자의 쓰임새가 있으니 상대적인 장단점을 이해하고 사용하는 것이 좋다. 그렇다고 하더라도 정적 팩터리를 사용하는 게 유리한 경우가 더 많으므로 무작정 public 생성자를 제공하던 습관이 있다면 고치자.

## 아이템 2 생성자에 매개변수가 많다면 빌더를 고려하라

* 생성자, 정적 팩터리는 선택 매개변수가 많을 때 대응하기 어렵다.
* 점층적 생성자 패턴: 필수 매개변수부터 선택 매개변수까지 점층적으로 나열하여 여러 개의 생성자를 만드는 방식. 별로다.
* 자바빈스 패턴: 매개변수 없이 객체를 만들고 setter 로 값을 설정하는 방식. 객체를 만들 때마다 많은 메서드를 호출해야 한다. 불변 인스턴스도 불가능하다.
* 빌더 패턴: 파이썬, 스칼라의 named optional parameters 를 흉내낸 패턴. 읽고 사용하기 쉽다.
* 생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면 빌더 패턴을 선택하는 게 더 낫다. 매개변수 중 다수가 필수가 아니거나 같은 타입이면 특히 더 그렇다. 빌더는 점층적생성자보다 클라이언트 코드를 읽고 쓰기가 훨씬 간결하고, 자바빈스보다 훨씬 안전하다.

## 아이템 3 private 생성자나 열거 타입으로 싱글턴임을 보증하라
* 싱글턴: 인스턴스가 하나뿐인 클래스. 예: 무상태 클래스, 함수, 유일 시스템 컴포넌트
* 싱글턴은 테스트가 어렵다. 모킹이 불가능하기 때문.
* 싱글턴 만드는 방법 1: private 생성자, 싱글턴 접근용 public static 멤버 제공.
	* 장점 1: API를 보고 싱글턴임을 알 수 있음
	* 장점 2: 간결함
* 싱글턴 만드는 방법 2: 정적 팩터리 메서드를 public static 멤버로 제공
	* 장점 1: API를 변경하지 않고도 싱글턴이 아닌 것으로 변경할 수 있음
	* 장점 2: 정적 팩터리를 제너릭 싱글턴 팩터리로 만들 수 있음
	* 장점 3: 정적 팩터리의 메서드 참조를 공급자로 사용할 수 있음
* 역직렬화로 인한 중복 인스턴스 발생 이슈를 고려해야 한다. `readResolve()` 인스턴스를 오버라이드하면 된다.
* 싱글턴 만드는 방법 3: 원소가 하나인 열거 타입 선언. 대부분 상황에서 싱글턴을 만드는 가장 좋은 방법이다.

## 아이템 4 인스턴스화를 막으려거든 private 생성자를 사용하라
* 클래스에 정적 메서드, 정적 필드만 모아놓는 경우. 예: 유틸리티 클래스
* 유틸리티 클래스는 인스턴스화하면 안 된다.
* 생성자를 명시하지 않으면 컴파일러가 기본 public 생성자를 만든다. 사용자는 이게 자동인지 아닌지 모른다.
* 추상 클래스로 만들어도 클래스를 확장해서 인스턴스화할 수 있다.
* private 생성자를 정의하면 인스턴스화를 막을 수 있다. 이렇게 하면 또한 상속도 막힌다.

## 아이템 5 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
* 자원을 정적 유틸리티 클래스나 싱글턴으로 구현하는 건 안티 패턴이다.
* 자원을 갈아낄 수 있어야 된다.
* 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다.
* 의존 객체 주입 패턴: 인스턴스를 생성할 때 생성자에 필요한 자원을 입력하는 방식
* 핵심 정리: 클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸리티 클래스는 사용하지 않는 것이 좋다. 이 자원들을 클래스가 직접 만들게 해서도 안 된다. 대신 필요한 자원을 (혹은 그 자원을 만들어주는 팩터리를) 생성자에 (혹은 정적 팩터리나 빌더에) 넘겨주자. 의존 객체 주입이라 하는 이 기법은 클래스의 유연성, 재사용성, 테스트 용이성을 기막히게 개선해준다.

## 아이템 6 불필요한 객체 생성을 피하라
* 안티 패턴: String 리터럴을 가지고 String 객체를 만드는 예.
* 생성자 대신 정적 팩터리 메서드를 써라. `Boolean(String)` =>`Boolean.valueOf(String)`
* 생성 비용이 비싼 객체를 캐시해라. 예: 정규식 Pattern 객체
* 오토박싱: 불필요하게 객체를 만들어 냄. 기본 타입을 대신 써라.

## 아이템 7 다 쓴 객체 참조를 해제하라
* 가비지 컬렉션이 있어도 메모리 관리에 신경을 써야 한다.
* 객체에 참조가 있으면 메모리가 해제되지 않는데, 참조된 객체가 다른 객체를 참조하는 식으로 해제되지 않는 메모리가 많아질 수 있다.
* 객체 사용후 직접 null으로 지정하는 건 불필요하다. 이름공간에서 밀어내는 것으로 충분하다.
* 메모리 누수의 주범 1: 컬렉션을 직접 구현하는 경우
* 메모리 누수의 주범 2: 캐시. 점수가 낮은 항목을 정리하는 걸 잊지 마라.
* 메모리 누수의 주범 3: 리스너, 콜백. 콜백 등록 후 해지하지 않는 경우.
* 핵심 정리: 메모리 누수는 겉으로 잘 드러나지 않아 시스템에 수년간 잠복하는 사례도 있다. 이런 누수는 철저한 코드 리뷰나 힙 프로파일러 같은 디버깅 도구를 동원해야만 발견되기도 한다. 그래서 이런 종류의 문제는 예방법을 익혀두는 것이 매우 중요하다.


## 아이템 8 finalizer와 cleaner 사용을 피하라
* 자바의 객체 소멸자는 finalizer, cleaner 두 가지다.
* finailzer는 예측할 수 없고 위험할 수 있으며 불필요하다. 쓰지 마라.
* cleaner는 역시 여전히 예측할 수 없고, 느리고, 불필요하다. 쓰지 마라.
* C++의 destructor와는 다르다.
* 메모리 자원은 가비지 콜렉터가 회수하고, 비메모리 자원의 회수는 try-with-resources 와 try-finally로 관리한다.
* finalizer와 cleaner의 문제점
	* 즉시 수행된다는 보장이 없다. 즉시 회수해야 하는 자원을 회수할 수 없다.
	* 수행 여부조차 보장하지 않는다.
	* 심각한 성능 문제도 동반한다.
	* finalizer 공격에 노출되어 심각한 보안 문제를 일으킬 수도 있다.
* 자원 관리 대안
	* `AutoCloseable`을 구현하고, `close()` 호출
* 핵심 정리: cleaner(자바 8까지는 finalizer)는 안전망 역할이나 중요하지 않은 네이티브 자원 회수용으로만 사용하자. 물론 이런 경우라도 불확실성과 성능 저하에 주의해야 한다.


## 아이템 9 try-finally보다는 try-with-resources를 사용하라
* 과거에는 자원을 닫기 위해 try-finally 를 썼다. 하지만 자원이 여러개인 경우 코드가 너무 지저분해진다.
* try-with-resources 이 좋은 대안이다.
* try-with-resources에서도 catch 절을 쓸 수 있다.
* 파이썬에도 비슷한 개념 있음: https://python.bakyeono.net/chapter-9-5.html#952-try-%EB%AC%B8%EC%97%90%EC%84%9C-%EB%92%B7%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0
* 핵심 정리: 꼭 회수해야 하는 자원을 다룰 때는 try-finall 말고, try-with-resources를 사용하자. 예외는 없다. 코드는 더 짧고 분명해지고, 만들어지는 예외 정보도 훨씬 유용하다. try-finally로 작성하면 실용적이지 못할 만큼 코드가 지저분해지는 경우라도, try-with-resources로는 정확하고 쉽게 자원을 회수할 수 있다.

