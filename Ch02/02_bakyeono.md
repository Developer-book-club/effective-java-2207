# 2장 객체 생성과 파괴

## 아이템 1 생성자 대신에 정적 팩터리 메서드를 고려하라

* 인스턴스 생성 수단: public 생성자, 정적 팩터리 메서드
* 정적 팩터리 메서드: 그냥 인스턴스를 반환하는 정적 메서드
* 장점 1: 이름을 가질 수 있다.
* 장점 2: 반드시 인스턴스를 새로 만들지 않아도 된다.
* 장점 3: 반환 타입의 하위 타입의 객체를 반환할 수 있다.
* 장점 4: 인자에 따라 다른 하위 타입의 객체를 반환할 수 있다.
* 장점 5: 정적 팩터리 메서드를 정의하는 시점에, 반환할 객체의 클래스가 정의되지 않아도 된다.
* 단점 1: 정적 팩터리 메서드만으로는 하위 클래스를 만들 수 없다. 상속을 하려면 public-protected 생성자가 필요하다.
* 단점 2: 정적 팩터리 메서드를 찾기 어렵다. 그래서 명명 관례를 사용한다.
* 명명 관례
	* from: 인자 하나를 형 변환
	* of: 인자를 모아 적합한 인스턴스 반환
	* valueOf: from, of의 더 자세한 버전
	* instance, getInstance: 인자로 지정한 인스턴스 반환
	* create, newInstance: 새 인스턴스 생성
	* getType: 다른 클래스에 팩터리 메서드를 정의할 때 사용 `A.getB()`
	* newType: 다른 클래스에 팩터리 메서드를 정의할 때 사용 `A.newB()`
	* type: getType, newType 의 간결한 버전
* 핵심 요약: 정적 팩터리 메서드와 public 생성자는 각자의 쓰임새가 있으니 상대적인 장단점을 이해하고 사용하는 것이 좋다. 그렇다고 하더라도 정적 팩터리를 사용하는 게 유리한 경우가 더 많으므로 무작정 public 생성자를 제공하던 습관이 있다면 고치자.

## 아이템 2 생성자에 매개변수가 많다면 빌더를 고려하라

* 생성자, 정적 팩터리는 선택 매개변수가 많을 때 대응하기 어렵다.
* 점층적 생성자 패턴: 필수 매개변수부터 선택 매개변수까지 점층적으로 나열하여 여러 개의 생성자를 만드는 방식. 별로다.
* 자바빈스 패턴: 매개변수 없이 객체를 만들고 setter 로 값을 설정하는 방식. 객체를 만들 때마다 많은 메서드를 호출해야 한다. 불변 인스턴스도 불가능하다.
* 빌더 패턴: 파이썬, 스칼라의 named optional parameters 를 흉내낸 패턴. 읽고 사용하기 쉽다.
* 생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면 빌더 패턴을 선택하는 게 더 낫다. 매개변수 중 다수가 필수가 아니거나 같은 타입이면 특히 더 그렇다. 빌더는 점층적생성자보다 클라이언트 코드를 읽고 쓰기가 훨씬 간결하고, 자바빈스보다 훨씬 안전하다.

## 아이템 3 private 생성자나 열거 타입으로 싱글턴임을 보증하라
* 싱글턴: 인스턴스가 하나뿐인 클래스. 예: 무상태 클래스, 함수, 유일 시스템 컴포넌트
* 싱글턴은 테스트가 어렵다. 모킹이 불가능하기 때문.
* 싱글턴 만드는 방법 1: private 생성자, 싱글턴 접근용 public static 멤버 제공.
	* 장점 1: API를 보고 싱글턴임을 알 수 있음
	* 장점 2: 간결함
* 싱글턴 만드는 방법 2: 정적 팩터리 메서드를 public static 멤버로 제공
	* 장점 1: API를 변경하지 않고도 싱글턴이 아닌 것으로 변경할 수 있음
	* 장점 2: 정적 팩터리를 제너릭 싱글턴 팩터리로 만들 수 있음
	* 장점 3: 정적 팩터리의 메서드 참조를 공급자로 사용할 수 있음
* 역직렬화로 인한 중복 인스턴스 발생 이슈를 고려해야 한다. `readResolve()` 인스턴스를 오버라이드하면 된다.
* 싱글턴 만드는 방법 3: 원소가 하나인 열거 타입 선언. 대부분 상황에서 싱글턴을 만드는 가장 좋은 방법이다.

## 아이템 4 인스턴스화를 막으려거든 private 생성자를 사용하라
* 클래스에 정적 메서드, 정적 필드만 모아놓는 경우. 예: 유틸리티 클래스
* 유틸리티 클래스는 인스턴스화하면 안 된다.
* 생성자를 명시하지 않으면 컴파일러가 기본 public 생성자를 만든다. 사용자는 이게 자동인지 아닌지 모른다.
* 추상 클래스로 만들어도 클래스를 확장해서 인스턴스화할 수 있다.
* private 생성자를 정의하면 인스턴스화를 막을 수 있다. 이렇게 하면 또한 상속도 막힌다.

## 아이템 5 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
* 자원을 정적 유틸리티 클래스나 싱글턴으로 구현하는 건 안티 패턴이다.
* 자원을 갈아낄 수 있어야 된다.
* 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다.
* 의존 객체 주입 패턴: 인스턴스를 생성할 때 생성자에 필요한 자원을 입력하는 방식
* 핵심 정리: 클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸리티 클래스는 사용하지 않는 것이 좋다. 이 자원들을 클래스가 직접 만들게 해서도 안 된다. 대신 필요한 자원을 (혹은 그 자원을 만들어주는 팩터리를) 생성자에 (혹은 정적 팩터리나 빌더에) 넘겨주자. 의존 객체 주입이라 하는 이 기법은 클래스의 유연성, 재사용성, 테스트 용이성을 기막히게 개선해준다.

## 아이템 6 불필요한 객체 생성을 피하라
* 안티 패턴: String 리터럴을 가지고 String 객체를 만드는 예.
* 생성자 대신 정적 팩터리 메서드를 써라. `Boolean(String)` =>`Boolean.valueOf(String)`
* 생성 비용이 비싼 객체를 캐시해라. 예: 정규식 Pattern 객체
* 오토박싱: 불필요하게 객체를 만들어 냄. 기본 타입을 대신 써라.


## 아이템 7 다 쓴 객체 참조를 해제하라

TODO

## 아이템 8 finalizer와 cleaner 사용을 피하라

TODO

## 아이템 9 try-finally보다는 try-with-resources를 사용하라

TODO

