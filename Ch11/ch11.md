# 11장 동시성

## 아이템 78. 공유 중인 가변 데이터는 동기화해 사용하라

* 동기화(synchronized 키워드로 해당 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장)의 용도
  1. 한 스레드가 변경하는 중이라서 상태라서 상태가 일관되지 않은 순간의 객체를 다른 스레드가 보지 못하게 lock(베타적 실행) = 객체의 상태가 일관되지 않은 순간을 볼 수 없도록
  2. 동기화된 메서드나 블록에 들어간 스레드가 같은 락의 보호하에 수행된 모든 이전 수정의 최종 결과를 반환
* 언어적 수준에서 long과 double 외의 변수를 읽고 쓰는 동작은 원자적(atomic)이라, 여러 스레드가 같은 변수를 동기화 없이 수정하는 중이라도, 항상 어떤 스레드가 정상적으로 저장한 값을 온전히 읽어옴(read)을 보장한다.
* 그러나 스레드가 완전히 반영된 값을 읽는 것은 보장하지만, 한 스레드에서 저장한 값(write)이 다른 스레드에 보이는가를 보장하지는 않기때문에, 스레드 사이의 안정적인 통신을 위해 동기화는 필요하다.
* 가변 데이터를 원자적으로 보장해도 동기화에 실패하는 사례(다른 스레드를 멈추는 경우)
  ```java
  // Thread.stop은 deprecated되었으므로 사용하지 말자
  // 코드 78-1. 잘못된 코드
  public class StopThread {
  	private static boolean stopRequested;
  	
  	public static void main(String[] args)
  		throws InterruptedException {
  		Thread backgroundThread = new Thread(() -> {
  			int i = 0;
  			while (!stopRequested)
  				i++;
  		});
  		backgroundThread.start();
  		
  		TimeUnit.SECONDS.sleep(1);
  		stopRequested = true;
  	}
  }
  ```
  위 코드는 메인 스레드에서 수정(write)하고 해당 값을 백그라운드 스레드가 언제 보게 될 지 보증할 수 없다. 또는 가상머신이 while(true)와 같이 끌어올리기(hoisting)최적화를 수행하게 프로그램이 응답 불가(liveness failure)가 될수도 있다.
  ```java
  // 코드 78-2. 적절히 동기화해 스레드가 정상 종료한다.
  public class StopThread {
  	private static boolean stopRequested;
  	
  	private static synchronized void requestStop() {
  		stopRequested = true;
  	}
  	
  	private static synchronized boolean stopRequested() {
  		return stopRequested;
  	}
  	
  	public static void main(String[] args)
  		throws InterruptedException {
  		Thread backgroundThread = new Thread(() -> {
  			int i = 0;
  			while (!stopRequested())
  				i++;
  		});
  		backgroundThread.start();
  		
  		TimeUnit.SECONDS.sleep(1);
  		requestStop();
  	}
  }
  ```
  쓰기 메서드(requestStop)와 읽기(stopRequested)를 모두 동기화(synchronized)하여 동기화 보장
* volatile : 항상 가장 최근에 기록된 값을 읽게됨을 보장

  코드 78-1에서 stopRequested 필드를 volatile로 선언하면 동기화를 생략 가능하고, 속도가 더 빠르다.
  ```java
  // 코드 78-4. 잘못된 코드 - 동기화가 필요하다!
  private static volatile int nextSerialNumber = 0;
  
  public static int generatedSerialNumber() {
  	return nextSerialNumber++;
  }
  ```
    매번 고유한 값을 반환할 의도로 만들어졌으나, 위 증가 연산자(++) 처럼 코드상 하나로 보이지만, 실제로 필드에 두번 접근할 경우, 두 접근 사이에 스레드가 값을 변경하면 동일한 값이 중복 반환 될 수 있는 안전 실패(safety failure)와 같은 오류가 발생할 수 있기 때문에 조심해서 사용해야한다.
* java.util.concurrent.atomic 패키지(락 없이(lock-free) 스레드 안전한 프로그래밍을 지원)의  AtomicLong을 사용하면 동기화의 통신 용도 뿐 아니라 원자성(배타적 실행)까지 지원하며 성능도 우수
  ```java
  // 코드 78-5. java.util.concurrent.atomic을 이용한 lock-free 동기화
  private static final AtomicLong nextSerialNum = new AtomicLong();
  
  public static long generatedSerialNumber() {
  	return nextSerialNum.getAndIncrement();
  }
  ```
* 애초에 가변 데이터를 공유하지 말고, 불변 데이터만 공유하거나 아무것도 공유하지 말도록(가변 데이터는 단일 스레드에서만 사용) 정책을 세우고 문서로 남겨 정책 유지
* 한 스레드가 데이터를 다 수정한 후 다른 스레드에 공유할때, 해당 객체에서 공유하는 부분만 동기화하면 다른 스레드들은 동기화 없이 자유롭게 값 획득 가능하며 이를 사실상 불변(effectively immutable)이라고 하고, 다른 스레드에 이런 객체를 건내는 행위를 안전 발행(safe publication)이라 한다.
* 객체를 안전하게 발행하는 방법
  1. 클래스 초기화 과정에서 객체를 정적 필드, volatile 필드, final 필드, 혹은 보통의 락을 통해 접근 하는 필드에 저장
  2. 동시성 컬렉션에 저장
## 아이템 79. 과도한 동기화는 피하라
* 과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 예측할 수 없는 동작 수행
* 응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안된다.
  * 동기화 영역 안에서는 재정의할 수 있는 메서드를 호출하거나, 클라이언트가 넘겨준 함수 객체 호출 금지(외계인 메서드(alien method))
  ```java
  // 코드 79-1. 잘못된 코드. 동기화 블록 안에서 외계인 메서드를 호출한다.
  public class ObservableSet<E> extends ForwardingSet<E> {
  	public ObservableSet(Set<E> set) { super(set); }
  	
  	private final List<SetOvserver<E>> observers
  		= new ArrayList<>();
  	
  	public void addObserver(SetObserver<E> observer) {
  		synchronized(observers) {
  			observers.add(observer);
  		}
  	}
  	
  	public boolean removeObserver(SetObserver<E> observer) {
  		synchronized(observers) {
  			return observers.remove(observer);
  		}
  	}
  	
  	private void notifyElementAdded(E element) {
  		synchronized(observers) {
  			for (SetObserver<E> observer : observers)
  				observer.added(this, element);
  		}
  	}
  	
  	@Override public boolean add(E element {
  		boolean added = super.add(element);
  		if (added)
  			notifyElementAdded(element);
  		return added;
  	)
  	
  	@Override public boolean addAll(Collection<? extends E> c) {
  		boolean result = false;
  		for (E element : c)
  			result = add(element);	// notifyElementAdded를 호출한다.
  		return result;
  	}
  }
  ```
  0부터 99까지 출력(실행부)
  ```java
  public static void main(String[] args) {
  	ObserverableSet<Integer> = 
  		new ObserverableSet<>(new HashSet<>());
  		
  	set.addObserver((s, e) -> System.out.println(e));
  	
  	for (int i = 0; i < 100; i++)
  		set.add(i);
  }
  ```
  평상시에는 집합에 추가된 정수값 출력, 23일때 자기 자신을 제거(구독해지)하는 관찰자 추가
  ```java
  	set.addObserver(new SetObserver<>() {
  		public void added(ObservableSet<Integer> s, Integer e) {
  			System.out.println(e);
  			if (e == 23)
  				s.removeObserver(this);
  		}
  	});
  ```
  0부터 23까지 출력 후 관찰자 자신을 구독해지한 다음 종료될것으로 기대하나, 실제로 실행하면 23까지 출력 후 ConcurrentModificationException 발생(관찰자의 added 메서드 호출이 일어난 시점이 notifyElementAdded가 관찰다들의 리스트를 순회하는 도중이기때문. added 메서드는 ObservableSet의 removeObserver 메서드를 호출하고, 이 메서드는 다시 observers.remove 메서드를 호출 -> 리스트에서 원소를 제거하려는데, 해당 리스트를 순회하는 도중) 
  ```java
  // 코드 79-2 쓸데없이 백그라운드 스레드를 사용하는 관찰자
  set.addObserver(new SetObserver<> () {
  	public void added(ObservableSet<Integer> s, Integer e) {
  		System.out.println(e);
  		if (e == 23) {
  			ExecutorService exec = 
  				Executors.newSingleThreadExecutor();
  			try {
  				exec.submit(() -> s.removeObserver(this)).get();
  			} catch (ExecutionException | InterruptedException ex) {
  				throw new AssertionError(ex);
  			} finally {
  				exec.shutdown();
  			}
  		}
  	}
  });
  ```
  위 코드는 교착 상태 발생(백그라운드 스레드가 s.removeObserver를 호출하고나면 관찰자를 잠그려 시도하지만 락을 메인 스레드가 쥐고 있어 얻을 수 없고, 메인 스레드는 관찰자를 제거하기를 대기)
* 교착 상태(응답 불가)가 발생하면 다행이지만, 락이 재구실을 하지 못하여 안전 실패(데이터 훼손) 발생
* 이러한 문제는 외계인 메서드 호출을 동기화 블록 바깥으로 이동하여 해결
  ```java
  코드 79-3. 외계인 메서드를 동기화 블록 바깥으로 옮겼다.
  private void notifyElementAdded(E element) {
  	List<SetObserver<E>> snapshot = null;
  	synchronized(observers) {
  		snapshot = new ArrayList<>(observers);
  	}
  	for (SetObserver<E> observer : snapshot)
  		observer.added(this, element);
  }
  ```
* 자바의 동시성 컬렉션 라이브러리의 CopyOnWriteArrayList를 대체하여 사용하면 순회할때 락이 필요 없어 매우 빠르다(내부를 변경하는 작업은 항상 복사본을 만들어 수행)
  ```java
  // 코드 79-4. CopyOnWriteArrayList를 사용해 구현한 스레드 안전하고 관찰 가능한 집합
  private final List<SetObserver<E>> observers = 
  	new CopyOnWriteArrayList<>();
  
  public void addObserver(SetObserver<E> observer) {
  	observers.add(observer);
  }
  
  public boolean removeObserver(SetObserver<E> observer) {
  	return observers.remove(observer);
  }
  
  private void notifyElementAdded(E element) {
  	for (SetObserver<E> observer : observers)
  		observer.added(this, element)
  }
  ```
* 코드 79-3처럼 동기화 영역 바깥에서 호출되는 외계인 메서드 = 열린 호출(open call) : 실패 방지 효과 + 동시성 효율 개선
* 기본 규칙은 동기화 영역에서는 가능한 일을 적게 하는 것
* 멀티코어가 일반화된 오늘날 과도한 동기화가 초래하는 비용은 락을 얻는 데 드는 CPU 시간이 아니라 경쟁하느라 낭비되는 시간(병렬 실행 기회를 잃고 메모리를 일관되게 보기위한 지연시간)이고,  가상 머신의 코드 최적화를 제한할 수 있다.
* 가변 클래스를 작성하려면
  1. 동기화를 전혀 하지 말고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화하도록
  2. 동기화를 내부에서 수행해 스레드 안전한 클래스로 작성(외부에서 거는것보다 동시성을 월등히 개선할 수 있을 때)

## 아이템 80. 스레드보다는 실행자, 태스크, 스트림을 애용하라
* 실행자 프레임워크 : 인터페이스 기반의 유연한 태스크 실행 기능(java.util.concurrent)
  1. 작업 큐 생성 : `ExecutorService exec = Executors.newSingleThreadExecutor();`
  2. 실행할 작업(task)를 넘기는 방법 : `exec.execute(runnable);`
  3. 실행자 종료(이 작업이 실패하면 VM 자체가 종료되지 않음) : `exec.shutown();`
* 실행자 서비스의 주요 기능
  * 특정 태스크가 완료되기를 기다린다.(get 메서드)
  * 태스크 모음 중 하나(invokeAny 메서드) 혹은 모든 태스크(invokeAll 메서드)가 완료되기를 기다린다.
  * 실행할 서비스가 종료하기를 기다린다(awaitTermination 메서드).
  * 완료된 태스크들의 결과를 차례로 받는다(ExecutorCompletionService 이용).
  * 태스크를 특정 시간에 혹은 주기적으로 실행하게 한다(ScheduledThreadPoolExecutor 이용)
* 다른 종류의 실행자 서비스(java.util.concurrent.Executors의 정적 팩터리 이용)
  * 큐를 둘 이상의 스레드가 처리하게 하고싶다면 ThreadPoolExecutor 클래스를 사용하여 스레드 풀 생성(스레드 개수 고정, 필요에 따라 증감 설정 가능)
  * 작은 프로그램이나 가벼운 서버라면 Executors.newCachedThreadPool 사용 : CachedThreadPool은 요청받은 태스크가 큐에 쌓이지 않고 즉시 스레드에 위임돼 실행하나 무거운 프로덕션 서버에는 부적합
  * 무거운 프로덕션 서버에서는 스레드 개수를 고정한 Executors.newFixedThreadPool을 선택하거나 완전히 통제할 수 있는 ThreadPoolExecutor를 직접 사용
* 작업 큐를 손수 만드는 일, 스레드를 직접 다루는 일은 삼가야 한다 : 스레드를 직접 다루면 Thread가 작업 단위와 수행 매커니즘 역할을 모두 수행하는데, 실행자 프레임워크에서는 작업 단위와 실행 메커니즘 분리 가능
  * 작업 단위 추상 개념 = 태스크(Task)
    1. Runnable
    2. Callable(Runnable과 비슷하지만 값을 반환하고 임의의 예외 throw 가능)
  * 태스크 수행 매커니즘 = 실행자 서비스
  * 태스크 수행을 실행자 서비스에 맡기면 원하는 태스크 수행 정책 선택 가능, 변경 용이
* 자바 7에서 실행자 프레임워크는 포크-조인(fork-join) 태스크 지원
  * 포크-조인 태스크는 포크-조인 풀이라는 특별한 실행자 서비스가 실행
  * ForkJoinTask의 인스턴스는 작은 하위 태스크로 구성되며 ForkJoinPool을 구성하는 스레드들이  이 하위 태스크를 실행
  * 일이 먼저 끝난 스레드는 다른 스레드의 남은 태스크를 가져와 대신 처리 가능(CPU를 최대한 활용하여 높은 처리량과 낮은 지연시간 달성)
* "자바 병렬 프로그래밍" 참고
## 아이템 81. wait와 notify보다는 동시성 유틸리티를 애용하라
* 기존 wait와 notify는 올바르게 사용하기가 아주 까다롭기때문에 자바 5에서 도입된 고수준의 동시성 유틸리티 사용
* java.util.concurrent의 고수준 유틸리티
  1. 실행자 프레임워크
  2. 동시성 컬렉션(concurrent collection)
      * List, Queue, Map 같은 표준 컬렉션 인터페이스에 동시성을 가미해 구현한 고성능 컬렉션
      * 높은 동시성을 도달하기 위해 동기화를 각자 내부에서 수행하므로, 동시성을 무력화하는것은 불가능하며, 외부에서 락을 추가로 사용하면 오히려 성능 저하
      * '상태 의존적 수정' 메서드 : 여러 메서드를 원자적으로 묶어서 호출이 불가능하여 추가됨
	      * Map의 putIfAbsend(key, value) 메서드 : 주어진 키에 매핑된 값이 아직 없을 때만 새 값 추가하고, 기존 값이 있었으면 반환, 없었으면 null 반환 -> 스레드 안전한 정규화 맵(canonicalizing map) 구현 가능
	      ```java
	      // String.intern의 동작 흉내
	      // 코드 81-1. ConcurrentMap으로 구현한 동시성 정규화 맵 - 최적은 아니다.
	      private static final ConcurrentMap<String, String> map = 
	      	new ConcurrentHashMap<>();
	      
	      public static String intern(String s) {
	      	String previousValue = map.putIfAbsent(s, s);
	      	return previousValue == null ? s : previousValue;
	      }
	      ```
	      위 코드는 ConcurrentHashMap이 get 같은 검색 기능에 최적화되어있으므로, get을 먼저 호출하여 필요할 때만 putIfAbsent를 호출하여 성능 개선 가능
	      ```java
	      // 코드 82-1. ConcurrentMap으로 구현한 동시성 정규화 맵 - 더 빠르다!
	      public static String intern(String s) {
	      	String result = map.get(s);
	      	if (result == null) {
	      		result = map.putIfAbsent(s, s);
	      		if (result == null)
	      			result = s;
	      	}
	      	return result;
	      }
	      ```
	  * 기존 동기화한 컬렉션을 동시성 컬렉션으로 교체하면 동시성 성능 개선 가능(ex. Collections.synchronizedMap보다는 ConcurrentHashMap을 사용) 
	  * 컬렉션 인터페이스 중 일부는 작업이 성공적으로 완료될 때까지 기다리도록(차단되도록) 확장(ex. Queue를 확장한 BlockingQueue에 추가된 메서드 중 take는 큐의 첫 원소를 꺼내는데, 만약 큐가 비었다면 새로운 원소가 추가될때까지 기다릴 수 있어 작업 큐(생산자-소비자 큐)로 사용하기에 적합하기때문에 ThreadPoolExecutor를 비롯한 대부분의 실행자 서비스 구현체에서 이 BlocingQueue를 사용)
  3. 동기화 장치(synchronizer)
      * 스레드가 다른 스레드를 기다릴 수 있게 하여, 서로 작업 조율 가능
        * CountDownLatch : 유일한 생성자는 int 값을 받으며, 이 값이 래치의 countDown 메서드를 몇번 호출해야 대기 중인 스레드들을 깨우는지 결정 -> 유용한 기능 쉽게 구현 가능
            * 어떤 동작들을 동시에 시작해 모두 완료하기까지의 시간 측정 프레임워크
            ```java
            // 코드 81-3 동시 실행 시간을 재는 간단한 프레임워크
            public static long time(Executor executor, int concurrency, Runnable action) throws InterruptedException {
            	CountDownLatch ready = new CountDownLatch(concurrency);
            	CountDownLatch start = new CountDownLatch(1);
            	CountDownLatch done = new CountDownLatch(concurrency);
            	
            	for(int i = 0; i < concurrency; i++) {
            		executor.execute(() -> {
            			// 타이머에게 준비를 마쳤음을 알린다.
            			ready.countDown();
            			try {
            				// 모든 작업자 스레드가 준비될 때까지 기다린다.
            				start.await();
            				action.run();
            			} catch (InterruptedException e) {
            				Thread.currentThread().interrupt();
            			} finally {
            				// 타이머에게 작업을 마쳤음을 알린다.
            				done.countDown();
            			}
            		});
            	}
            	
            	ready.await();	// 모든 작업자가 준비될 때까지 기다린다.
            	long startNanos = System.nanoTime();
            	start.countDown();	// 작업자들을 깨운다.
            	done.await();	// 모든 작업자가 일을 끝마치기를 기다린다.
            	return System.nanoTime() - startNanos;
            }
            ```
            time 메서드에 넘겨진 실행자(executor)는 concurrency 매개변수로 지정한 동시성 수준만큼의 스레드를 생성 가능해야한다. 그렇지 못하면 스레드 기아 교착상태(thread starvation deadlock)에 빠져 끝나지 않을 것
            * 위 카운트다운 래치 3개는 CyclicBarrier(혹은 Phaser) 인스턴스 하나로 대체 가능
* 레거시 코드라면 wait나 notify 사용 필요
  * wait 메서드는 반드시 그 객체를 잠근 동기화 영역 안에서 호출
  ```java
  // 코드 81-4 wait 메서드를 사용하는 표준 방식
  synchronized (obj) {
  	while (<조건이 충족되지 않았다>)
  		obj.wait();	// (락을 놓고, 깨어나면 다시 잡는다.
  	
  	...	// 조건이 충족됐을 때의 동작을 수행한다.
  }
  ```
  wait 메서드를 사용할 때는 반드시 대기 반복문(wait loop) 관용구를 사용하고 반복문 밖에서는 절대로 호출하지 말것. 조건이 이미 충족되었는데 스레드가 notify(혹은 notifyAll) 메서드를 먼저 호출한 후 대기 상태로 빠지면 그 스레드를 다시 깨울 수 있다고 보장 불가능
  * 대기 후에 조건을 검사하여 조건이 충족되지 않았다면 다시 대기하게하는 것은 안전 실패 방지. 조건이 충족되지 않았는데, 스레드가 동작을 이어가면 락이 보호하는 불변식을 깨드릴 수 있다.
  * 조건이 만족되지 않아도 스레드가 깨어날 수 있는 상황
	  - 스레드가 notify를 호출한 다음 대기 중이던 스레드가 깨어나는 사이에 다른 스레드가 락을 얻어 그 락이 보호하는 상태를 변경
	  - 조건이 만족하지 않았음에도 다른 스레드가 실수로 혹은 악의적으로 notify 호출(공개된 객체를 락으로 사용해 대기하는 클래스)
	  - 깨우는 스레드에 지나치게 관대해서, 대기중인 스레드 중 일부만 조건이 충족되어도 notifyAll을 호출해 모든 스레드를 깨울 수도 있다.
	  - 허위 각성(spurious wakeup)이라는 현상으로 대기 중인 스레드가 드물게 notify 없이도 깨어나는 경우
  * 그 외에 notify, notifyAll 선택 문제 존재
  	- notifyAll 사용하여 모든 스레드가 깨어남을 보장하는것을 추천)
 	- 모든 스레드가 같은 조건을 기다리고 있고, 조건이 한 번 충족될 때마다 단 하나의 스레드만 혜택을 받을 수 있다면 notifyAll 대신 notify를 사용해 최적화 가능
 	- 그럼에도 불구하고 외부로 공개된 객체에 대해 실수/악의적으로 notify를 호출하는 상황에 대비하기 위해, wait를 반복문 안에서 호출했듯, notifyAll 사용
## 아이템 82. 스레드 안전성 수준을 문서화하라
* API 문서에 한 메서드를 여러 스레드가 동시에 호출할 때 그 메서드가 어떻게 동작하는지 언급이 없으면 클래스 사용자가 나름의 가정을 해야하며, 동기화를 불충분/지나치게하여 심각한 오류로 이어질 수 있다.
* API 문서에 synchronized 한정자가 보이는 메서드는 스레드 안전하다고하더라고, 메서드 선언에 synchronized 한정자를 선언할지는 구현 이슈로 그것만으로 스레드 안전하다고 확신 불가능
* 멀티스레드 환경에서도 API를 안전하게 사용하려면, 클래스가 지원하는 스레드 안정성 수준을 정확히 명시해야한다.
* 스레드 안정성 수준(높은순)
	1. 불변(immutable) : 상수와 같아서 외부 동기화 필요 없음(String, Long, BigInteger) = @Immutable
	2. 무조건적 스레드 안전(unconditionally thread-safe) : 인스턴스는 수정될 수 있으나, 내부에서 충실히 동기화하여 별도의 외부 동기화 없이 사용해도 안전(AtomicLong, ConcurrentHashMap) = @ThreadSafe
	3. 조건부 스레드 안전(conditionally thread-safe) : 일부 메서드는 동시에 사용하려면 외부 동기화 필요(Collections.synchronized 래퍼 메서드가 반환한 컬렉션으로 이 컬렉션들이 반환한 반복자는 외부에서 동기화 필요) = @ThreadSafe
	4. 스레드 안전하지 않음(not thread-safe) : 동시에 사용하려면 각각의(일련의) 메서드 호출을 클라이언트가 선택한 외부 동기화 메커니즘으로 감싸야 한다.(ArrayList, HashMap 같은 기본 컬렉션) = @NotThreadSafe
	5. 스레드 적대적(thread-hostile) : 모든 메서드 호출을 외부 동기화로 감싸더라도 멀티스레드 환경에서는 안전하지 않다(일반적으로 정적 데이터를 아무 동기화 없이 수정하는 경우)
* 조건부 스레드 안전한 클래스는 어떤 순서로 호출할 때 외부 동기화가 필요한지, 그 순서로 호출하려면 어떤 락 혹은 락들을 얻어야하는지 명시 필요
	- 일반적으로 인스턴스 자체를 락으로 얻지만 Collections.synchronizedMap처럼 반환한 맵의 컬렉션 뷰를 순회하려면 반드시 그 맵을 락으로 사용해 수동으로 동기화하라고 API 문서에 명시된 경우가 있다.
* 클래스의 스레드 안정성은 보통 클래스의 문서화 주석에 기재하지만, 독특한 특성의 메서드라면 해당 메서드의 주석에 기재
* 열거 타입은 굳이 불변 명시 불필요
* 반환 타입만으로는 명확히 알 수 없는 정적 팩터리는 자신이 반환하는 객체의 스레드 안전성 문서화 필요(ex. Collections.synchronizedMap)
* 클래스가 외부에서 사용할 수 있는 락을 제공하면, 클라이언트에서 일련의 메서드 호출을 원자적으로 수행 가능하나, 내부에서 처리하는 고성능 동시성 제어 메커니즘과 혼용할 수 없어 ConcurrenctHashMap 같은 동시성 컬렉션과는 함께 사용 불가능하고, 클라이언트가 공개된 락을 오래 쥐고 놓지 않는 서비스 거부 공격(denial-of-service attack) 수행 가능 - synchronized 메서드 대신 비공개 락 객체 사용 필요
  ```java
  // 코드 82-1 비공개 락 객체 관용구 - 서비스 거부 공격을 막아준다.
  private final Object lock = new Object();	// lock 필드는 항상 final로 선언
  
  public void foo() {
  	synchronized(lock) {
  		...
  	}
  }
  ```
  비공개 락 객체 관용구는 무조건적 스레드 안전 클래스에서만 사용 가능
  * 비공개 락 객체 관용구는 상속용으로 설계한 클래스에 적합. 자신의 인스턴스를 사용하면 의도치 않게 기반 클래스의 동작을 방해할 수 있다.(하위 클래스와 기반 클래스가 서로 훼방놓는 상태)
## 아이템 83. 지연 초기화는 신중히 사용하라

## 아이템 84. 프로그램의 동작을 스레드 스케줄러에 기대지 말라
* 여러 스레드가 실행 중일 때, 운영체제의 스케줄 스케줄러가 어떤 스레드를 얼마나 오래시킬지 결정하기 때문에 정확성이나 성능이 스케줄 스케줄러에 따라 달라지는 프로그램은 다른 플랫폼에 이식하기 어려움
* 실행 가능한 스레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록하여(실행 준비가 된 스레드들은 맡은 작업을 완료할 때까지 계속 실행되도록) 스레드 스케줄링 정책이 상이한 시스템에서도 동작이 크게 달라지지 않는다.
* 실행 가능한 스레드 수를 적게 유지하는 주요 기법 : 각 스레드가 무언가 유용한 작업을 완료한 후에는 다음 일거리가 생길때까지 대기
* 스레드가 당장 처리할 작업이 없으면 실행돼서는 안된다.
* 스레드는 절대 바쁜 대기(busy waiting) 상태가 되면 안된다.
  ```java
  // 끔찍한 CountDownLatch 구현 - 바쁜 대기 버전!
  public class SlowCountDownLatch {
	  private int count;
	  
	  public SlowCountDownLatch(int count) {
	  	if (count < 0)
	  		throw new IllegalArgumentException(count + " < 0");
	  		this.count = count;
	  }
	  
	  public void await() {
	  	while(true) {	// 공유 객체의 상태가 바뀔 때까지 쉬지 않고 검사
	  		synchronized(this) {
	  			if (count == 0)
	  				return;
	  		}
	  	}
	  }
	  
	  public synchronized void countDown() {
	  	if (count != 0)
	  		count--;
	  }
  ```
* Thread.yield를 사용하지 말것(테스트도 불가능하고, 성능 효과도 없고, 이식성도 불가능)
* 스레드 우선순위도 이식성이 나쁘다.