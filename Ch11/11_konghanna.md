# 아이템 78: 공유 중인 가변 데이터는 동기화해 사용하라

### synchronized 키워드
- 해당 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장
- 동기화의 기능
  - 1) 객체의 일관성이 깨진 상태를 볼 수 없게 함 (배타적 실행)
  - 2) 동기화된 메서드나 블록에 들어간 스레드가 같은 락의 보호하에 수행된 모든 이전 수정의 최종 결과를 보게 해줌 (스레드 사이의 안정적인 통신)

### 원자적(atomic)
- 자바 언어 명세상  long과 double 외의 변수를 읽고 쓰는 것은 원자적 
  - 원자적 = 여러 스레드가 같은 변수를 동기화 없이 수정하는 중이라도, 항상 어떤 스레드가 정상적으로 저장한 값을 온전히 읽어옴을 보장
  - but, 스레드가 필드를 읽을 때 '수정이 완전히 반영된' 값을 얻는 것은 보장하지만, 한 스레드가 저장한 값이 다른 스레드에게 '보이는지'는 보장하지 않음 -> 원자적 데이터를 사용할 때도 동기화해야 함 -> 동기화는 배타적 실행뿐만 아니라 스레드 사이의 안정적인 통신을 위해 꼭 필요함 
  
### 동기화가 필요한 이유
- ex) 다른 스레드를 멈추는 작업
  - 동기화하지 않으면 메인 스레드가 수정한 boolean 변수의 값을 백그라운드 스레드가 언제쯤 보게 될지 보장할 수 없음 
  - JVM이 끌어올리기(hoisting)라는 최적화 기법을 적용할 수 있음 
  - -> 응답 불가(liveness failure) 상태가 됨
  - 동기화는 쓰기 메서드, 읽기 메서드에 대해 모두 적용해야함

### 동기화의 대안1: volatile 한정자
- 배타적 수행과는 상관없지만 가장 최근에 기록된 값을 읽어옴

### 동기화의 대안2: atomic 패키지
- 락 없이도 스레드 안전한 프로그래밍을 지원하는 클래스들이 담겨 있음
- volatile은 동기화의 효과 중 통신 쪽만 지원하지만 이 패키지는 원자성(배타적 실행)까지 지원
- 성능도 동기화 버전보다 우수함

### 동기화 문제를 피하기 위한 원칙
1. 불변 데이터만 공유하거나 가변 데이터를 공유하지 말고 단일 스레드에서만 사용할 것
2. 한 스레드가 데이터를 수정한 후 다른 스레드에 공유할 때는 해당 객체에서 공유하는 부분만 동기화할 것
    - 전달되는 객체: 불변
    - 다른 스레드에 이런 객체를 건네는 행위: 안전 발행
      - 안전 발행 방법: 클래스 초기화 과정에서 객체를 정적 필드, volatile 필드, final 필드, 보통의 락을 통해 접근하는 필드, 동시성 컬렉션에 저장

<br><br>

# 아이템 79: 과도한 동기화는 피하라 
- 과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 예측할 수 없는 동작을 낳음
- 응답 불가와 안전 실패를 피하려면 동기화 메서드, 블록 안에서는 클라이언트에 제어를 양도하면 안 됨
  - 동기화된 영역 안에서는 재정의할 수 있는 메서드, 클라이언트가 넘겨준 함수 객체를 호출하면 안 됨 -> 이런 외계인 메서드가 하는 일에 따라 동기화된 영역은 예외를 일으키거나, 교착상태에 빠지거나, 데이터를 훼손할 수 있음 

### 예외 및 교착상태 해결방법
- 기본 규칙: 동기화 영역에서는 가능한 한 일을 적게 하는 것
1. 외계인 메서드 호출 코드를 동기화 블록 바깥으로 옮기기 (열린 호출)
2. 자바의 동시성 컬렉션 사용 
    - CopyOnWriteArrayList
      - ArrayList를 구현한 클래스로, 내부를 변경하는 작업은 항상 깨끗한 복사본을 만들어 수행하도록 함
      - 내부의 배열은 수정되지 않아 순회할 때 락이 필요 없어 매우 빠름

### 성능 개선 방법
- 과도한 동기화는 병렬로 실행할 기회를 잃고, 모든 코어가 메모리를 일관되게 보기 위한 지연시간을 발생시키고, 가상머신의 코드 최적화를 제한함  
- 가변 클래스 작성 방법 
  - 1) 동기화를 하지 말고, 그 클래스를 사용해야 하는 클래스가 외부에서 동기화하게 함
    - ex) java.util 패키지 -  Vector와 Hashtable을 제외
  - 2) 동기화를 내부에서 수행해 스레드 안전한 클래스로 만듦 
    - 클라이언트가 외부에서 객체 전체에 락을 거는 것보다 동시성을 월등히 개선할 수 있을 때만 선택할 것 
    - ex) java.util.concurrent 패키지 

<br><br>

# 아이템 80: 스레드보다는 실행자, 태스크, 스트림을 애용하라 

### 실행자 프레임워크 
- java.util.concurrent 패키지는 실행자 프레임워크라고 하는 인터페이스 기반의 유연한 태스크 실행 기능을 담고 있음 
- 실행자 프레임워크의 주요 기능
  - 1) 특정 태스크가 완료되기를 기다림 (get 메서드)
  - 2) 태스크 모음 중에서 아무것 하나(invokeAny 메서드) 혹은 모든 태스크(invokeAll 메서드)가 완료되는 것을 기다림
  - 3) 실행자 서비스가 종료하기를 기다림 (awaitTermination 메서드)
  - 4) 완료된 태스크들의 결과를 차례로 받음 (ExecutorCompletionService)
  - 5) 태스크를 특정 시간에 혹은 주기적으로 실행하게 함 (ScheduledThreadPoolExecutor)

### ThreadPool
- Executors.newCachedThreadPool
  - 작은 프로그램을 실행하기에 적합 
  - 요청받은 태스크들이 큐에 쌓이지 않고 즉시 스레드에 위임돼 실행됨, 가용한 스레드가 없으면 새로 하나 생성함 
  - 서버가 무겁다면 CPU 이용률이 100%로 치닫고 새로운 태스크가 도착할 때마다 다른 스레드를 생성하며 상황이 더 악화됨
  - -> 무거운 프로덕션 서버에는 Executors.newFixedThreadPool을 선택하여 스레드 개수를 고정하거나, 완전히 통제할 수 있는 ThreadPoolExecutor을 사용할 것  

### 실행자 프레임워크를 사용해야 하는 이유
- 작업 큐를 직접 만들거나 스레드를 직접 다루는 것도 일반적으로 삼가야 함
  - 스레드를 직접 다루면 스레드가 작업 단위와 수행 메커니즘 역할을 모두 수행하게 됨
  - 실행자 프레임워크에서는 작업 단위와 실행 메커니즘이 분리됨
    - 작업 단위(태스크)
      - Runnable 
      - Callable: 값을 반환하고 임의의 예외를 던질 수 있음
    - 실행자 서비스: 태스크를 수행하는 일반적인 메커니즘 
      - 실행자 프레임워크가 작업 수행을 담당해줌 
- 포크-조인(fork-join) 태스크를 지원해줌 (자바7~)
  - ForkJoinTask 인스턴스: 작은 하위 태스크로 나뉠 수 있고, ForkJoinPool을 구성하는 스레드들이 이 태스크들을 처리함, 일을 먼저 끝낸 스레드가 다른 스레드의 남은 태스크를 가져와 대신 처리하기도 함 
  - -> CPU를 최대한 활용하면서 높은 처리량과 낮은 지연시간을 달성함


(....) 










