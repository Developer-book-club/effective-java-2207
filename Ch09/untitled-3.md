# 9장 일반적인 프로그래밍 원칙

## 아이템 57. 지역변수의 범위를 최소화하라

* 지역변수의 유효 범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성 하락
* 지역변수의 범위를 줄이는 가장 강력한 기법 : 가장 처음 쓰일 때 선언하기
* 지역변수의 범위 : 선언된 지점부터 그 지점을 포함한 블록을 끝날 때까지
* 거의 모든 지역변수는 선언과 동시에 초기화해야 한다 - 초기화에 필요한 정보가 충분해질 때까지 선언을 미뤄야한다. try-catch문에서는 예외인데, 변수를 초기화하는 표현식에서 검사 예외가 발생한 가능성이 있다면, try 블록 안에서 초기화해야하며, 변수 값을 try 블록 바깥에서 사용해야한다면 try 블록 앞에서 선언해야한다.
* 반복문에서는 반복 변수의 범위가 반복문의 몸체, 그리고 for 키워드와 몸체 사이의 괄호 안으로 제한(for, for-each 형태 등)되며, 반복 변수의 값을 반복문이 종료된 뒤에도 써야 하는 상황이 아니라면 while 문보다 for 문 권장
* 반복자를 사용해야 하는 상황이면 for-each 문 대신 전통적인 for 문 사용
```
for (Iterator<Element> i = c.iterator(); i.hasNext(); ) {
	Element e = i.next();
	...	// e로 무언가를 한다.
}
```
* while 문에서는 복사 & 붙여넣기 시 오류가 발생할 가능성 존재 : 프로그램 오류가 겉으로 드러나지 않을 수 있다. 전통적인 for 문을 사용하면, 컴파일 타임에 오류를 발견할 수 있고, 변수 유효 범위가 for 문 범위와 일치하여 똑같은 이름의 변수를 사용할 수 있으며, 코드가 짧아서 가독성이 좋다.
* 같은 값을 반환하는 메서드를 매번 호출하는 비용을 없애기 위해 아래와 같은 반복문 관용구 사용
```
for (int i = 0, n = expensiveComputation(); i < n; i++) {
	...	// i로 무언가를 한다.
}
```
* 메서드를 작게 유지하고 한 가지 기능에 집중하라

## 아이템 58. 전통적인 for 문보다는 for-each 문을 사용하라

컬렉션이나 배열 순회 시 전통적인 for 문을 사용하면 while보다는 낫지만, 반복자와 인덱스 변수는 코드를 지저분하게 할뿐 진짜 필요한것은 원소들뿐이기 때문에, for-each 문을 사용하는 것이 좋다.(enhanced for statement) 하나의 관용구로 컬렉션과 배열을 모두 처리 가능
```
// 전통적인 for 문 : 컬렉션 순회
for (Iterator<Element> i = c.iterator(); i.hasNext(); ) {
	Element e = i.next();
	...	// e로 무언가를 한다.
}
// 전통적인 for 문 : 배열 순회
for (int i = 0; i < a.length; i++) {
	... // a[i]로 무언가를 한다.
}
// for-each 문(컬렉션과 배열을 모두 처리 가능)
for (Element e : elements) {
	... // e로 무언가를 한다.
}
```
* 컬렉션이든, 배열이든 속도는 동일
* 컬렉션 중첩 순회 시 이점이 더욱 커진다(사용자 실수 방지)

* for-each 문을 사용할 수 없는 상황
  1. 파괴적인 필터링(destructive filtering) : 컬렉션을 순회하면서 선택한 원소ㄹ,ㄹ 제거(반복자의 remove 메서드 호출)해야 할 때(자바 8부터는 Collection의 removeIf 메서드를 사용)
  2. 변형(transforming) : 리스트나 배열 순회 시 원소의 값 일부 혹은 전체를 교환해야할 때
  3. 병렬 반복(parallel iteration) : 여러 컬렉션을 병렬로 순회해야 할 때
* for-each 문은 컬렉션과 배열은 물론 Iterable 인터페이스를 구현한 객체라면 무엇이든 순회 가능

## 아이템 59. 라이브러리를 익히고 사용하라

* 일반적인 문제 해결은 표준 라이브러리를 사용하여 그 코드를 작성한 전문가의 지식과 앞서 사용한 다른 프로그래머들의 경험 활용 가능
  1. 알고리즘에 능통한 개발자가 설계와 구현과 검증에 시간을 들여 개발했고, 여러 전문가가 잘 동작함을 검증(ex. random 메서드)
  2. 핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 된다.
  3. 성능이 지속적으로 개선
  4. 기능이 점점 많아진다.
  5. 많은 사람에게 낯익은 코드가 된다. 다른 개발자들이 더 읽기 좋고, 유지보수하기 좋고, 재활용하기 쉬운 코드가 된다.
* 많은 사람들이 라이브러리에 그런 기능이 있는지 몰라 직접 구현
* 메이저 릴리즈마다 주목할 만한 수많은 기능이 라이브러리에 추가된다.(InputStream의 transferTo 메서드 - URL의 내용 가져오기)
* 적어도 java.lang, java.util, java.io와 그 하위 패키지들에는 익숙해져야한다.
* 언급해둘 만한 라이브러리
  1. 컬렉션 프레임워크
  2. 스트림 라이브러리
  3. java.util.concurrent의 동시성 기능 : 멀티스레드 프로그래밍 작업을 단순화해주는 고수준의 편의 기능과 능숙한 개발자가 자신만의 고수준 개념을 직접 구현할 수 있도록 도와주는 저수준 요소 제공
* 자바 표준 라이브러리에서 원하는 기능을 찾지 못하면 고품질의 서드파티 라이브러리를 선택(ex. 구글의 구아바 라이브러리)하고, 서드파티 라이브러리에서도 찾지 못하면 직접 구현하라

## 아이템 60. 정확한 답이 필요하다면 float와 double은 피하라
* float와 double 타입은 과학과 공학 계산용으로 이진 부동소수점 연산에 쓰이며 넓은 범위의 수를 빠르게 정밀한 '근사치'로 계산하도록 설계 - 정확한 결과가 필요할 때는 사용하면 안된다.(특히 금융 관련 계산)
* 금융 계산에는 BigDecimal, int 혹은 long 사용
* BigDecimal의 단점 : 기본 타입보다 쓰기가 훨씬 불편하고 훨씬 느리다.
* int, long 타입을 쓸 경우 다룰 수 있는 값의 크기가 제한되고, 소수점을 직접 관리해야한다.

## 아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하라

* 기본 타입 : int, double, boolean 등
* 참조 타입 : String, List 등
* 박싱된 기본 타입 : Integer, Double, Boolean 등
* 오토박싱과 오토언박싱 덕분에 기본 타입과 박싱된 기본 타임을 구분하지 않고 사용 가능
* 기본 타입과 박싱된 기본 타입의 차이
  1. 기본 타입은 값만 가지고 있고, 박싱된 기본 타입은 값에 더해 식별성(identity) 속성 존재(값이 같아도 다르다고 식별될 수 있음)
  2. 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은 값(null)을 가질 수 있다.
  3. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.
```
Comparator<Integer> naturalOrder = 
	(i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
// 별다른 문제는 없어보이나 naturalOrder.compare(new Integer(42), new Integer(42))의 값은
// 0이 아닌 1을 출력
```
```
public class Unbelievable {
	static Integer i;
	
	public static void main(String[] args) {
		if(i == 42)
			System.out.println("믿을 수 없군!");
	}
}
// 기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 오토언박싱되며,
// null 참조를 언박싱하면 NullPointException 발생
```
```
public static void main(String[] args) {
	Long sum = 0L;
	for (long i = 0; i <= Integer.MAX_VALUE; i++) {
		sum += i;
	}
	System.out.println(sum);
}
// sum이 박싱된 기본 타입으로 선언하여, 연산 시 박싱과 언박싱이 반복해서 일어나 성능이 느려진다.
```
* 박싱된 기본 타입을 써야하는 경우
  1. 컬렉션의 원소, 키, 값으로 쓴다.(컬렉션은 기본 타입을 담을 수 없으므로)
  2. 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수
  3. 리플렉션을 통해 메서드를 호출할 때

## 아이템 62. 다른 타입이 적절하다면 문자열 사용을 피하라
* 파일, 네트워크, 키보드 입력으로부터 데이터를 받을 때, 받을 데이터가 수치형이라면 int, float, BigInteger 등 적당한 수치 타입으로 변환하고, 예/아니오 질문의 답이라면 적절한 열거 타입이나 boolean을 변환해야 한다.(기본 타입이든 참조 타입이든 적절한 값 타입이 있다면 그것을 사용하고, 없다면 새로 작성하라)
* 문자열은 열거 타입을 대신하기에 적합하지 않다.
* 문자열은 혼합 타입을 대신하기에 적합하지 않다.(구분자를 이용하여 파싱하는 경우 느리고, 귀찮고, 오류 가능성도 커지며, equals, toString, compareTo 메서드 제공 불가)
* 문자열은 권한을 표현하기에 적합하지 않다.(보안에도 취약)

## 아이템 63. 문자열 연결은 느리니 주의하라
* 문자열 연결 연산자(+)로 문자열 n개를 잇는 시간은 n^2에 비례(문자열은 불변이라서 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사해야하므로)
* 성능을 위해서는 String 대신 StringBuilder 사용

## 아이템 64. 객체는 인터페이스를 사용해 참조하라
* 객체는 클래스가 아닌 인터페이스로 참조하라(객체의 실제 클래스를 사용해야 할 상황은 오직 생성자로 생성할 때 뿐)
```
// 좋은 예
Set<Son> sonSet = new LinkedHashSet<>();

// 나쁜 예
LinkedHashSet<Son> sonSet = new LinkedHashSet<>();
```
* 인터페이스 타입을 사용하면 프로그램이 훨씬 유연해진다.(추후 구현 클래스 교체 시 다른 생성자(혹은 정적 팩터리)를 호출하기만 하면 된다.)
* 원래의 클래스가 인터페이스의 일반 규약 이외의 특별한 기능을 제공하며, 주변 코드가 이 기능에 기대어 동작한다면 새로운 클래스도 반드시 같은 기능을 제공해야 한다.
* 인터페이스 대신 클래스 타입을 사용해도 되는 예
  1. 구현 타입을 바꾸려 하는 동기 : 성능이 좋거나 신기능 제공
  2. 적합한 인터페이스가 없다면 클래스 참조(그래도 보통 특정 구현 클래스보다는 기반 클래스 사용하여 참조)
  3. 인터페이스에는 없는 특별한 메서드를 제공하는 클래스
* 객체를 표현할 적절한 인터페이스를 찾아서 참조하고, 적합한 인터페이스가 없다면 클래스 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인(상위) 클래스를 타입으로 사용

## 아이템 65. 리플렉션보다는 인터페이스를 사용하라
* 리플렉션의 장점
  1. 리플렉션 기능(java.lang.reflection)을 이용하면 프로그램에서 임의의 클래스에 접근 가능
  2. 클래스의 멤버 이름, 필드 타입, 메서드 시그니처 등 획득 가능
  3. 생성자, 메서드, 필드 조작 가능
  4. 컴파일 당시에 존재하지 않던 클래스 이용 가능
* 리플렉션의 단점
  1. 컴파일타입 타입 검사 불가(예외 검사 포함)
  2. 코드가 지저분해고 장황해진다
  3. 성능이 떨어진다
* 코드 분석 도구나 의존관계 주입 프레임워크 처럼 복잡한 애플리케이션 말고는 필요 없을 가능성이 크다.
* 제한된 형태로만 사용해야 그 단점을 피하고 이점을 취할 수 있다.
* 인스턴스 생성에만 쓰고 생성된 인스턴스는 인터페이스나 상위 클래스로 참조해 사용
* 런타임에 존재하지 않을 수도 있는 다른 클래스, 메서드, 필드와의 의존성을 관리할 때 적합

## 아이템 66. 네이티브 메서드는 신중히 사용하라
* 자바 네이티브 인터페이스(JNI)는 자바 프로그램이 C, C++ 같은 네이티브 메서드를 호출하는 기능
  1. 레지스트리 같은 플랫폼 특화 기능 사용
  2. 네이티브 코드로 작성된 기존 라이브러리 사용
  3. 성능 개선의 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성
* 자바가 성숙해가면서 (OS 같은) 하부 플랫폼의 기능을 점차 흡수하여 네이티브 메서드를 사용할 필요가 계속 줄어들고 있다.
* 성능을 개선할 목적으로 네이티브 메서드를 사용하는 것은 거의 권장하지 않는다.
* 네이티브 메서드의 단점
  1. 네이티브 언어가 안전하지 않으므로 네이티브 메서드를 사용하는 애플리케이션도 메모리 훼손 오류로부터 안전하지 않다.
  2. 자바보다 플랫폼을 많이 타서 이식성도 낮다
  3. 디버깅도 더 어렵다.
  4. 주의하지 않으면 속도가 오히려 느려질 수도 있다.
  5. 가비지 컬렉터가 네이티브 메모리는 자동 회수하지 못하고, 심지어 추적조차 할 수 없다.
  6. 자바 코드와 네이티브 코드의 경계를 넘나들 때마다 비용도 추가된다.
  7. 접착 코드를 작성해야하는데, 귀찮기도하고, 가독성도 떨어진다.

## 아이템 67. 최적화는 신중히 하라
* 최적화는 좋은 결과보다는 해로운 결과로 이어지기 쉽다.
* 빠른 프로그램보다는 좋은 프로그램을 작성하라.
* 좋은 프로그램은(좋은 아키텍쳐) 정보 은닉 원칙을 따르므로 개별 구성요소의 내부를 독립적으로 설계할 수 있어, 시스템의 나머지에 영향을 주지 않고도 각 요소를 다시 설계할 수 있다.
* 구현상의 문제는 나중에 최적화해 해결할 수 있지만, 아키텍쳐의 결함이 성능을 제한하면, 시스템 전체를 다시 작성하지 않고는 해결하기가 불가능하다.
* 성능을 제한하는 설계를 피하라
* API를 설계할 때 성능에 주는 영향을 고려하라
* 신중하게 설계하여 깨끗하고 명확하고 멋진 구조를 갖춘 프로그램을 완성하고 최적화를 고려하라
* 각각의 최적화 시도 전후에 성능을 측정하라
* 프로파일링 도구로 최적화 노력을 어디에 집중해야 할지 찾는다.(90%의 시간을 10%의 코드에서 사용)

## 아이템 68. 일반적으로 통용되는 명명 규칙을 따르라
자바의 명명 규칙은 크게 철자와 문법, 두 범주로 나뉨
* 철자 규칙 : 패키지, 클래스, 인터페이스, 메서드, 필드, 타입 변수의 이름(특별한 이유가 없는 한 반드시 따라야 한다.)
  1. 패키지와 모듈 : 각 요소를 점(.)으로 구분하여 계층, 요소들은 모두 소문자 알파벳 혹은 숫자, 조직의 인터넷 도메인의 이름을 역순으로 사용 ex) org.junit.jupiter.api, com.google.common.collect
  2. 클래스와 인터페이스 : 하나 이상의 단어(각 단어는 대문자로 시작)하고 약자의 경우 첫 글자만 대문자 사용 ex) Stream, FutureTask, KinkedHashMap, HttpClient
  3. 메서드와 필드 : 첫 글자를 소문자로 사용 ex) remove, groupingBy, getCrc
  4. 상수 필드 : 모두 대문자 사용하고 단어 사이는 밑줄로 구분 ex) MIN_VALUE, NEGATIVE_INFINITY
  5. 지역변수 : 약어 사용 가능 ex) i, denom, houseNum
  6. 타입 매개변수 : 보통 한 문자로 표현 ex) T, E, K, V, X, R, U, V, T1, T2
* 문법 규칙
  1. 객체를 생성할 수 있는 클래스의 이름은 보통 단수 명사나 명사구 사용(Thread, PriorityQueue, ChessPiece 등)
  2. 객체를 생성할 수 없는 클래스의 이름은 보통 복수형 명사 사용(Collectors, Collections 등)
  3. 인터페이스 이름은 클래스와 같거나(Collection, Comparator 등), able 혹은 ible로 끝나는 형용사 사용(Runnable, Iterable, Accessible)
  4. 애너테이션은 명사, 동사, 전치사, 형용사 두루 사용(BindingAnnotation, Inject, ImplementedBy, Singleton 등)
  5. 어떤 동작을 수행하는 메서드의 이름은 동사나 (목적어를 포함한) 동사구 사용(append, draImage). boolean 값을 반환하는 메서드라면 보통 is나 has로 시작, 명사나 명사구, 혹은 형용사로 기능하는 아무 단어나 구로 끝나도록 사용(isDigit, isPrablablePrime, isEmpty, isEnabled, hasSiblings 등)
  6. 반환 타입이 boolean이 아니거나 해당 인스턴스의 속성을 반환하는 메서드의 이름은 보통 명사, 명사구, 혹은 get으로 시작하는 동사구로 짓는다(size, hashCode, getTime)