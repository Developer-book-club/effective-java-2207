# 아이템 15: 클래스와 멤버의 접근 권한을 최소화하라

- 잘 설계된 컴포넌트: 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 잘 숨겨서 구현과 API를 분리함 (정보 은닉, 캡슐화) 

### 정보 은닉의 장점
- 시스템을 구성하는 컴포넌트들을 서로 독립시켜서 개발, 테스트, 최적화 등을 개별적으로 할 수 있게 해줌
1. 개발 속도를 높여줌
   - 여러 컴포넌트를 병렬로 개발할 수 있기 때문
2. 관리 비용을 낮춰줌 
   - 각 컴포넌트를 더 빨리 파악할 수 있고 다른 컴포넌트로 교체하는 부담도 적기 때문
3. 성능 최적화에 도움을 줌
   - 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화할 수 있기 때문
4. 재사용성을 높임
   - 독자적으로 동작할 수 있는 컴포넌트라면 낯선 환경에서도 유용하게 쓰일 수 있음 
5. 큰 시스템을 제작하는 난이도를 낮춰줌 
   - 시스템 전체가 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있기 때문

### 접근 제어 메커니즘 
- 정보 은닉을 위해 클래스, 인터페이스, 멤버의 접근성(접근 허용 범위)를 명시하는 것
  - 각 요소의 접근성은 그 요소가 선언된 위치와 접근 제한자로 정해짐 <br> 
  -> 이 접근 제한자를 활용하는 것이 정보 은닉의 핵심 

### 컴포넌트 설계 원칙
- 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 함 <br>
  : 가장 낮은 접근 수준을 부여해야 함

1. 패키지 외부에서 쓸 이유가 없다면 package-private(default)으로 선언 
   - API가 아닌 내부 구현이 되어 자유롭게 수정할 수 있게 됨
2. package-private 클래스나 인터페이스 안에 private static 클래스를 중첩시켜보기 
   - 바깥 클래스 하나에서만 접근할 수 있게 됨
3. public일 필요가 없는 클래스의 접근 수준을 package-private 톱레벨 클래스로 좁히기 
   - public 클래스: 그 패키지의 API 
   - private-private 톱레벨 클래스: 내부 구현  
4. 클래스의 공개 API를 제외한 모든 멤버는 private으로 만들기
   - 같은 패키지의 다른 클래스가 접근해야 하는 멤버에 한하여 package-private로 풀어줄 것
   - private, package-private 멤버는 해당 클래스의 구현에 해당하므로 공개 API에 영향을 주지 않으나, Serializable을 구현한 클래스에서는 공개 API가 될 수도 있음 
   - public 클래스의 protected 멤버는 공개 API가 되므로 protected 멤버의 수는 적을수록 좋음
   - 상위 클래스의 메소드를 재정의할 때는 접근 수준을 상위 클래스보다 좁게 설정할 수 없음 
    - -> for 리스코프 치환 원칙(상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙)
  - 테스트만을 목적으로 클래스, 인터페이스, 멤버를 공개 API로 만들어서는 안됨
  - public 클래스의 인스턴스 필드는 되도록 public이 아니어야 함 
    - 불변식을 보장할 수 없고 일반적으로 스레드 안전하지 않음 
  - public static final 필드는 기본 타입 값이나 불변 객체를 참조해야 함 
     - 가변 객체를 참조할 시 참조된 객체 자체가 수정될 수 있음
       - public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 두면 안됨 (길이가 0이 아닌 배열은 모두 변경 가능하므로)
           - 해결책 1) public 배열을 private로 변경 + 변경 불가능한 public 리스트 추가  
           - 해결책 2) public 배열을 private로 변경 + 복사본을 반환하는 public 메서드 추가(방어적 복사) 

### cf. 접근 지정자 
- private
  - 멤버를 선언한 톱레벨 클래스에서만 접근 가능
- package-private
  - 멤버가 소속된 패키지 안의 모든 클래스에서 접근 가능
  - 접근 제한자를 명시하지 않았을 때 적용되는 접근 수준 (단, 인터페이스의 멤버는 기본적으로 public이 적용됨)
- protected
  - package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근 가능
- public 
  - 모든 곳에서 접근 가능

<br><br>

# 아이템 16: public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

```java
    class Point {
        public double x;
        public double y;
    }
```
- 데이터 필드에 직접 접근할 수 있게 하는 클래스는 캡슐화의 이점을 제공하지 못함
  - cf. java.awt.package 패키지의 Point, Dimension 클래스: public 클래스의 필드를 직접 노출시키는 클래스의 사례 
```java
    class Point {
        private double x;
        private double y;

        public Point(double x, double y){
            this.x = x;
            this.y = y;
        }
        public double getX() { return x; }
        public double getY() { return y; }

        public void setX(double x) { this.x = x; }
        public void setY(double y) { this.y = y; }
    }
```
  - 필드들을 모두 private로 바꾸고 public 접근자(getter)를 추가 -> 클라이언트가 필드를 사용하지 못하게 함으로써 클래스의 내부 표현 방식을 바꿀 수 있는 유연성을 얻게 됨
  - but, package-private 클래스, private 중첩 클래스라면 데이터 필드를 public으로 두어 노출해도 문제가 없음 
    - getter를 사용하는 방식보다 깔끔할 수 있음 
       - 클라이언트 코드가 패키지 or 클래스 안에서만 동작하는 코드이기 때문에 그 바깥의 코드를 손대지 않고도 데이터 표현 방식을 바꿀 수 있음 

### 핵심 정리
- public 클래스는 절대 가변 필드를 직접 노출해서는 안됨
  - 불변 필드인 경우: 불변식은 보장할 수 있으나 여전히 API를 변경하지 않고는 표현 방식을 바꿀 수 없고, 필드를 읽을 때 부수 작업을 수행할 수 없다는 단점이 존재 
- package-private 클래스나 private 중첩 클래스에서는 필드를 노출하는 편이 나을 수도 있음 

<br><br>

# 아이템 17: 변경 가능성을 최소화하라

- 불변 클래스: 인스턴스의 내부 값을 수정할 수 없는 클래스, 불변 인스턴스의 정보는 객체가 파괴되기 전까지 달라지지 않음
  - 가변 클래스보다 설계, 구현, 사용하기 쉬우며 안전함 

### 불변 클래스를 만드는 설계 방법
1. 객체의 상태를 변경하는 메소드(변경자)를 제공하지 않음
2. 클래스를 확장할 수 없도록 함 
   - 하위 클래스에서 객체의 상태를 바꾸지 못하게 함 (대표적인 방법은 클래스를 final로 선언하는 것)
3. 모든 필드를 final로 선언 
   - 설계자의 의도를 명확하게 드러내는 방법
   - 새로 생성된 인스턴스를 동기화 없이 다른 스레드로 건넬 때 문제없이 동작할 수 있게 보장 
4. 모든 필드를 private로 선언
   - 필드가 참조하는 가변 객체에 직접 접근해 수정하는 일을 막아줌
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 함
   - 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야 함
6. 피연산자를 수정하지 않고 반환하는 함수형 프로그래밍 방식을 적용할 시 불변이 되는 영역의 비율이 높아짐
7. 모든 생성자를 private 또는 package-private로 만들고 public 정적 팩터리를 제공 
```java
    public class Complex {
        private final double re;
        private final double im;

        private Complex(double re, double im) {
            this.re = re;
            this.im = im;
        }

        public static Complex valueOf(double re, double im) {
            return new Complex(re, im);
        }
        // -> 패키지 바깥에서 보면 사실상 final
    }
```
  - 정적 팩터리 방식: 다수의 구현 클래스를 활용한 유연성 제공, 다음 릴리스에서 객체 캐싱 기능을 추가해 성능 개선 가능

### 불변 객체의 특징
1. 스레드 안전하여 따로 동기화할 필요가 없고 안심하고 공유할 수 있음
   - 클래스를 스레드 안전하게 만드는 가장 쉬운 방법
   - 한 번 만든 인스턴스를 재활용하는게 좋음
     - 자주 쓰이는 값들을 상수(public static final)로 제공
     - 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스를 중복 생성하지 않게 해주는 정적 팩토리를 제공할 수 있음
     - 복사를 해도 원본과 똑같으니 의미 X: clone 메소드, 복사 생성자를 제공하지 않는게 좋음 
2. 불변 객체끼리 내부 데이터를 공유할 수 있음
3. 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 좋음
   - ex. 맵의 키, 집합의 원소로 쓰기 좋음
4. 그 자체로 실패 원자성을 제공함
   - 실패 원자성: 메소드에서 예외가 발생한 후에도 그 객체는 여전히 메소드 호출 전과 똑같은 유효한 상태여야 함

### 불변 객체의 단점
1. 값이 다르면 반드시 독립된 객체로 만들어야 함
   - ex. BigInteger에서 비트 하나를 바꾸기 위해 새로운 인스턴스를 만들어야 함
2. 원하는 객체를 완성하기까지의 단계가 많고 중간 단계에서 만들어지는 객체들이 모두 버려진다면 성능 문제가 생김
   - 해결책 1. 다단계 연산들을 기본적으로 제공 <br>
    -> 각 단계마다 객체를 생성하지 않아도 됨 
      - 가변 동반 클래스(companion class)  
          - ex. String 클래스의 StringBuilder

### 정리
- 클래스는 꼭 필요한 경우가 아니라면 불변이어야 함
  - 성능 때문에 어쩔 수 없다면 불변 클래스와 쌍을 이루는 가변 동반 클래스를 public 클래스로 제공할 것
- 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄여야 함
- 합당한 이유가 없다면 클래스의 모든 필드는 private final이어야 함
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 함
- 확실한 이유가 없다면 생성자와 정적 팩터리 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안됨 

<br><br>

# 아이템 18: 상속보다는 컴포지션을 사용하라

- 상속: 코드를 재사용하는 강력한 수단이지만, 항상 최선은 아님.
  - 상속은 메소드 호출과 달리 캡슐화를 깨뜨림
    - 상위 클래스의 구현 방식이 하위 클래스의 동작에 영향을 미침 
      - 메소드 재정의 시 상위 클래스의 내부 구현 방식을 정확히 알지 못하는 경우 예상과 다른 결과를 가져옴 cf. 메소드의 자기 사용 여부(HashSet의 addAll 메소드는 add 메소드를 사용하여 구현됨)를 모르는 경우

### 메소드 재정의 시 발생하는 문제 해결
1. 메소드를 재정의하는 대신 새로운 메소드를 추가
   - but, 상위 클래스에 새 메소드가 추가됐는데 하위 클래스에 추가한 메소드와 시그니처가 같고 리턴 타입만 다른 경우(같은 경우: 재정의한 것과 같음), 클래스는 컴파일이 안됨
   - 하위 클래스에서 만든 메소드는 상위 클래스의 새로운 메소드가 요구하는 규약을 만족하지 못할 가능성이 큼
2. 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 함
   - 기존 클래스가 새로운 클래스의 구성요소로 쓰임 = 컴포지션
   - 새 클래스의 인스턴스 메소드들은 기존클래스에 대응하는 메소드를 호출해 그 결과를 반환 = 전달 <br>
-> 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나며, 기존 클래스에 새로운 메소드가 추가되더라도 영향을 받지 않음

```java
   //HashSet의 모든 기능을 정의한 Set 인터페이스를 활용해 설계
   //래퍼 클래스
public class InstrumentedSet<E> extends ForwardingSet<E>  {
    private int addCount = 0;

    public InstrumentedSet(Set<E> s) {
        super(s);
    }

    @Override
    public boolean add(E e) {
        addCount++;
        return super.add(e);
    }

    @Override
    public boolean addAll(Collection<? extends E> c) {
        addCount += c.size();
        return super.addAll(c);
    }

    public int getAddCount() {
        return addCount;
    }
}

//전달 클래스
public class ForwardingSet<E> implements Set<E> {
    private final Set<E> set;
    public ForwardingSet(Set<E> set) { this.set = set; }
    public void clear() { set.clear(); }
    public boolean isEmpty() { return set.isEmpbty(); }
    public boolean add(E e) { return set.add(e); }
    public boolean addAll(Collection<? extends E> c) { return set.addAll(c); }
    // ...
}

```
- 래퍼 클래스: 다른 Set 인스턴스를 감싸고 있는 클래스
- 데코레이터 패턴: 다른 Set에 계측 기능을 덧씌워 새로운 Set으로 만듦 
- 위임(delegation): 컴포지션과 전달의 조합, 엄밀히는 래퍼 객체가 내부 객체에 자기 자신의 참조를 넘기는 경우만 해당됨

### 래퍼 클래스의 단점
1. 콜백 프레임워크 사용 시 SELF 문제 발생 가능성
      - 콜백 프레임워크에서는 자기 자신의 참조를 다른 객체에 넘겨서 다음 호출 때 사용하도록 하는데 내부 객체는 자신을 감싸고 있는 래퍼의 존재를 모르기 때문에 자신의 참조를 넘기고 콜백 때는 래퍼가 아닌 내부 객체를 호출하게 됨

 ### 상속을 해야하는 상황
 - 상속은 하위 클래스가 상위 클래스의 진짜 하위 타입인 상황에서만 사용해야 함 : is-a 관계일 때 (구성 요소일 때)

<br><br>

# 아이템 19: 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

### 문서화
- 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기 사용) 문서로 남겨야 함
- 재정의 가능 메서드(public과 protected 메서드 중 final 이 아닌 메서드)를 호출할 수 있는 모든 상황을 문서로 남겨야 함   

### 상속을 고려한 설계 방법
1. 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅을 잘 선별하여 protected 메서드 형태로 공개할 수도 있음
   - protected로 노출할 메서드 결정: 하위 클래스를 만들어서 검증 (하위 클래스를 여러 개 만들 때까지 사용되지 않는 멤버는 private이었어야 할 가능성이 높음) 
2. 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 됨
   - 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출되기 때문
     - private, final, static 메서드는 재정의가 불가능하므로 생성자에서 안심하고 호출해도 됨
3. Cloneable, Serializable 인터페이스를 구현한 클래스를 상속할 수 있게 설계하는 것은 지양
   - clone, readObject은 새로운 객체를 만드는 메서드로 생성자와 비슷한 효과를 냄 -> 재정의 가능 메서드를 호출해서는 안 됨
   - Serializable을 구현한 상속용 클래스가 readResolve, writeReplace 메서드를 갖는다면 이 메서드들은 private가 아닌 protected로 선언

### 상속을 금지하는 설계 방법
- 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것이 좋음

1. 클래스를 final로 선언
2. 모든 생성자를 private이나 package-private로 선언하고 public 정적 팩터리 만들어주기 

<br><br>

# 아이템 20: 추상 클래스보다는 인터페이스를 우선하라

### 자바 제공 다중 구현 메커니즘: 인터페이스, 추상 클래스
- 공통점
  - 두 메커니즘 모두 인스턴스 메서드를 구현 형태로 가질 수 있음(자바8-인터페이스에 디폴트 메서드 추가됨)
- 차이점
  - 추상 클래스가 정의한 타입을 구현한 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 함
    - 단일 상속만 지원하는 자바에서 추상 클래스를 상속한 클래스는 새로운 타입을 정의하기 어려움
    - 인터페이스를 구현한 클래스는 다른 어떤 클래스를 상속했든 같은 타입으로 취급됨 
  - 추상 클래스를 상속하기 위해서는 여러 제약이 따르지만  인터페이스는 메서드를 선언하기만 하면 쉽게 구현할 수 있음
    - 두 클래스가 같은 추상 클래스를 상속해야 한다면, 그 추상 클래스는 계층구조상 두 클래스의 공통 조상이어야 함

### 인터페이스의 특징
1. 믹스인 정의에 알맞음
   - 믹스인: 클래스가 구현할 수 있는 타입, 주된 타입 외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 줌
   - ex. Comparable: 클래스의 인스턴스들끼리 순서를 정할 수 있다고 선언하는 믹스인 인터페이스
2. 계층구조가 없는 타입 프레임워크를 만들 수 있음
3. 래퍼 클래스 관용구와 함께 사용하면 기능을 향상시키는 수단이 됨

### 인터페이스 + 추상 골격 구현 클래스 (Q)
- 인터페이스와 추상 클래스의 장점을 모두 취하는 방법
- 인터페이스로는 타입을 정의하고(필요하면 디폴트 메서드도 함께 제공), 골격 구현 클래스에는 나머지 메서드들을 구현함 <br>
-> 템플릿 메서드 패턴
- 단순 구현: 골격 구현의 작은 변종, 골격 구현과 같이 상속을 위해 인터페이스를 구현한 것이지만 추상 클래스가 아니란 점이 다름, 동작하는 가장 단순한 구현 

<br><br>

# 아이템 21: 인터페이스는 구현하는 쪽을 생각해 설계하라

- 기존 인터페이스에 메서드를 추가할 수 있게 됐지만(자바 8-디폴트 메서드) 인터페이스에 새로운 메서드를 추가하는 것은 어려움 
  - 디폴트 메서드가 기존 구현체와 잘 연동되지 않을 수 있으며 불변식을 해칠 수도 있음 <br>
    - ex. Collection 인터페이스에 추가된 removeIf와 apache 라이브러리의 SynchronizedCollection
    - 구현한 인터페이스의 디폴트 메서드를 재정의하고, 다른 메서드에서 디폴트 메서드를 호출하기 전 필요한 작업을 수행하도록 함 

### 인터페이스의 디폴트 메서드
- 디폴트 메서드는 컴파일에 성공하더라도 기존 구현체에 런타임 오류를 일으킬 수 있음 <br>
 -> 기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 일은 꼭 필요한 경우가 아니라면 피해야 함 
- 디폴트 메서드는 인터페이스로부터 메서드를 제거하거나 기존 메서드의 시그니처를 수정하는 용도가 아님   

<br><br>

# 아이템 22: 인터페이스는 타입을 정의하는 용도로만 사용하라

### 인터페이스의 용도
- 인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 함
- 클래스가 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있는지 클라이언트에게 얘기해주는 것

### 인터페이스를 잘못 사용한 예: 상수 인터페이스
- 상수 인터페이스: 메서드 없이 상수를 뜻하는 static final 필드로만 구성된 인터페이스
  - 상수는 클래스 내부에서 사용하는 내부 구현인데 상수 인터페이스를 구현하는 것은 내부 구현을 클래스의 API로 노출하는 것 

### 상수를 공개하는 방법
1. 클래스나 인터페이스 자체에 추가 
   - ex. Integer, Double 클래스의 MIN_VALUE, MAX_VALUE 상수
2. 열거(enum) 타입으로 만들기 
3. 인스턴스화 할 수 없는 유틸리티 클래스에 담기 

<br><br>

# 아이템 23: 태그 달린 클래스보다는 클래스 계층구조를 활용하라

- 태그 달린 클래스: 두 가지 이상의 의미를 표현할 수 있으며, 그중 현재 표현하는 의미를 태그 값으로 알려주는 클래스
- 태그 달린 클래스를 써야 하는 상황은 거의 없음 -> 태그 필드를 계층구조로 대체할 것

### 태그 달린 클래스의 단점
1. 열거(enum) 타입 선언, 태그 필드, switch 문장 등 쓸데없는 코드가 많음
2. 여러 구현이 한 클래스에 혼합돼 있어서 가독성이 나쁨
3. 다른 의미를 위한 코드가 함께 있으니 메모리를 많이 사용함 
4. 필드들을 final로 선언하려면 해당 의미에 사용되지 않는 필드들까지 생성자에서 초기화해야 함
   - 쓰지 않는 필드를 초기화하는 불필요한 코드가 늘어남
5. 또 다른 의미를 추가하려면 코드를 수정해야 함 (특히 switch 문)
6. 인스턴스의 타입만으로는 현재 나타내는 의미를 파악하기 어려움

### 태그 달린 클래스의 대안: 클래스 계층구조
- 추상 클래스
  - 태그 값에 따라 동작이 달라지는 메서드들을 추상 메서드로 선언
  - 태그 값에 상관없이 동작이 일정한 메서드들을 일반 메서드로 추가 
  - 모든 하위 클래스에서 공통으로 사용하는 데이터 필드 추가 
- 구체 클래스
  - 각자 필요한 데이터 필드 넣음 
  - 루트 클래스가 정의한 추상 메서들을 각자의 의미에 맞게 구현

### 클래스 계층구조의 장점
1. 각 의미를 독립된 클래스에 담았기 때문에 관련 없던 데이터 필드가 모두 제거됨
2. 각 생성자가 모든 필드를 남김없이 초기화해줌 
3. 실수로 빼먹은 case 문 때문에 런타임 오류가 발생할 일도 없음
4. 타입이 의미별로 따로 존재하기 때문에 변수의 의미를 명시하거나 제한할 수 있음
5. 타입 사이의 자연스러운 계층 관계를 반영할 수 있어서 유연성은 물론 컴파일 타임에서의 타입 검사 능력도 높여줌

<br><br>

# 아이템 24: 멤버 클래스는 되도록 static으로 만들라

### 중첩 클래스
- 다른 클래스 안에 정의된 클래스 
- 자신을 감싼 바깥 클래스에서만 사용되어야 하며, 그 외의 쓰임새가 있다면 톱레벨 클래스로 만들어야 함

### 중첩 클래스의 종류 1 : 정적 멤버 클래스, 비정적 멤버 클래스
1. 정적 멤버 클래스 (static 有)
   - 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다는 점만 제외하면 일반 클래스와 동일
   - 다른 정적 멤버와 똑같은 접근 규칙을 적용받음
   - 바깥 인스턴스 없이 객체 생성 가능
   - 바깥 클래스가 표현하는 객체의 구성요소를 나타낼 때 쓰임
2. 비정적 멤버 클래스 (내부 클래스/static 無)
   - 비정적 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결됨 
       - 정규화된 this(클래스명.this)를 통해 바깥 인스턴스의 메서드를 호출하거나 바깥 인스턴스의 참조를 가져올 수 있음
       - 바깥 인스턴스 없이 객체 생성 불가능
    - 어댑터를 정의할 때 자주 쓰임 -> 어떤 클래스의 인스턴스를 감싸 마치 다른 클래스의 인스턴스처럼 보이게 하는 뷰로 사용 (Q)
        - ex. Map 인터페이스의 구현체들이 컬렉션 뷰를 구현할 때, Set이나 List같은 컬렉션 인터페이스의 구현체들이 자신의 반복자를 구현할 때
- 멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들어야 함
  - static을 생략하면 바깥 인스턴스로의 숨은 외부 참조를 갖게 되는데, 이 참조를 저장하려면 시간과 공간이 소비됨
  - 가비지 컬렉션이 바깥 클래스의 인스턴스를 수거하지 못하는 메모리 누수가 생길 수 있음

### 중첩 클래스의 종류 2 : 익명 클래스, 지역 클래스        
3. 익명 클래스 (내부 클래스)
   - 이름이 없으며 바깥 클래스의 멤버도 아님
   - 선언과 동시에 인스턴스가 만들어지며 코드 어디서든 만들 수 있음 
   - 비정적 문맥에서 사용될 때만 바깥 인스턴스 참조 가능, 정적 문맥에서라도 상수 변수 이외의 정적 멤버를 가질 수 없음
   - 상수 표현을 위해 초기화된 final 기본 타입과 문자열 필드만 가질 수 있음
   - instanceof를 통한 타입 검사 불가능함
   - 여러 인터페이스를 구현할 수 없고 인터페이스 구현과 동시에 다른 클래스를 상속할 수 없음
   - 람다가 지원되기 전까지 작은 함수 객체, 처리 객체를 만드는 데 사용됨 -> 람다로 대체
   - 정적 팩터리 메서드를 구현할 때 사용됨 (Q)
4. 지역 클래스 (내부 클래스)
   - 지역변수를 선언할 수 있는 곳이면 어디서든 선언 가능, 유효 범위도 지역변수와 같음
   - 이름이 있고 반복해서 사용 가능(멤버 클래스와의 공통점)
   - 비정적 문맥에서 사용될 때만 바깥 인스턴스 참조 가능, 정적 멤버는 가질 수 없으며 가독성을 위해 짧게 작성해야 함(익명 클래스와의 공통점)

### 핵심 정리
- 메서드 밖에서도 사용해야 하거나 메서드 안에 정의하기에 너무 길면 멤버 클래스로 만듦
  - 멤버 클래스의 인스턴스가 바깥 인스턴스를 참조하면 -> 비정적 / 그렇지 않으면 -> 정적
- 한 메서드 안에서만 쓰이면서 그 인스턴스를 생성하는 지점이 단 한 곳이고 해당 타입으로 쓰기에 적합한 클래스나 인터페이스가 이미 있으면 -> 익명 클래스 / 그렇지 않으면 -> 지역 클래스 

<br><br>

# 아이템 25: 톱레벨 클래스는 한 파일에 하나만 담으라

- 소스 파일 하나에 톱레벨 클래스를 여러 개 선언하더라도 컴파일러가 오류를 발생시키지 않음
- 그러나 이런 경우 하나의 클래스가 여러 가지로 정의될 수 있고 어느 소스 파일을 먼저 컴파일하냐에 따라 결과가 달라짐

### 해결책 
- 톱레벨 클래스들을 서로 다른 파일에 분리
- 굳이 여러 톱레벨 클래스를 하나의 파일에 담고 싶다면 정적 멤버 클래스를 사용하는 방법을 고민해 볼 것(다른 클래스에 딸린 부차적인 클래스일 경우 일반적)
   - private로 선언 시 접근 범위도 최소로 관리할 수 있음
