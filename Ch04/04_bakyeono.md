# 4장 클래스와 인터페이스

## 아이템 15 클래스와 멤버의 접근 권한을 최소화하라

* 정보 은닉(캡슐화): 잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔히 분리한다.
* 정보 은닉의 장점
	* 높은 개발 속도: 여러 컴포넌트를 병렬로 개발할 수 있다.
	* 낮은 관리 비용: 컴포넌트 파악, 교체가 쉽다.
	* 성능 최적화 용이: 컴포넌트별로 프로파일링 가능
	* 컴포넌트의 재사용 가능성이 있다.
	* 대형 시스템 개발 낮이도를 낮춘다.
* 제한자 사용 원칙: 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.
* 탑레벨의 접근 수준: 공개 API이면 public, 아니라면 package-private 으로 설정한다.
		* public: API이므로 하위 호환을 영원히 관리해야 한다.
		* package-private: 내부 구현을 언제든 수정할 수 있다.
		* public일 필요가 없는 클래스의 접근 수준은 package-private 으로 좁힌다.
* 멤버의 접근 수준
		* private, package-private(기본값), protected, public(인터페이스 멤버의 기본값)
* 권한을 풀어야 하는 경우가 잦다면, 컴포넌트 분해가 필요한 신호일 가능성이 있다.
* public 클래스의 package-private 멤버를 protected 멤버로 변경하면 접근 가능 범위가 매우 넓어지므로 유의해야 한다.
* 상위 클래스의 메서드를 재정의할 때, 상위 클래스보다 접근성을 좁히는 것이 금지되어 있다. (리스코프 치환 원칙)
* 테스트를 위해 접근 범위를 넓혀야 하는 경우: 그러지 말고 그냥 같은 테스트를 대상과 같은 패키지에 두면 package-private 으로 접근 가능하다.
* public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다. 클래스가 그 객체에 어떤 값이 들어갈지 제한하는 능력이 상실된다.
* 정적 필드에서는 그 클래스의 개념에 반드시 필요한 상수에 한하여 public static final 로 공개할 수 있다. Math.PI 같은거 말하는 듯.
* 배열은 가변 데이터이므로 공개하지 마라.
* 자바 9의 모듈 시스템
	* 암묵적 접근 수준이 두 가지 추가되었다.
	* 모듈은 패키지들의 묶음이다.
	* 모듈은 패키지 중 공개(export)할 것들을 module-info.java에 정의한다.
	* 모듈이 공개하지 않은 패키지는 모듈 외부에서 접근하지 못한다.
	* 모듈 접근 제한시 주의점
		* JAR 파일을 모듈 경로 외 다른 클래스패스에 두면 모듈 접근 제한이 적용되지 않는다.
		* 모듈 시스템은 신경써야 하는 게 많으므로 꼭 필요하지 않다면 당분간 쓰지 마라.
* 핵심 정리: 프로그램 요소의 접근성은 가능한 한 최소한으로 하라. 꼭 필요한 것만 골라 최소한의 public API를 설계하자. 그 외에는 클래스, 인터페이스, 멤버가 의도치 않게 API로 공개되는 일이 없도록 해야 한다. public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안 된다. public static final 필드가 참조하는 객체가 불변인지 확인하라.


## 아이템 16 public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라
* 데이터 필드만 모아 놓은 클래스는 멤버를 public으로 설정하지 말고, getter, setter를 제공하라.
* package-private, private 중첩 클래스인 경우에는 데이터 필드를 노출해도 된다.
* 불변 데이터 필드도 직접 노출하지 않는 게 좋다.
	* 내부 구현 변경시 API 도 같이 변경해야 하는 단점
	* 필드 읽을 때 부원인을 설정할 수 없는 단점
* 핵심 정리: public 클래스는 절대 가변 필드를 직접 노출해서는 안 된다. 불변 필드라면 노출해도 덜 위험하지만 완전히 안심할 수는 없다. 하지만 package-private 클래스나 private 중첩 클래스에서는 종종 (불변이든 가변이든) 필드를 노출하는 편이 나을 때도 있다.


## 아이템 17 변경 가능성을 최소화하라
* 불변 클래스: 내부 데이터를 수정하지 못하는 클래스
	* 예: String, 기본 데이터의 박스 클래스, BigInteger, BigDecimal
	* 설계, 구현, 사용이 쉽고 오류가 적고 안전하다.
* 불면 클래스 만들기
	* 상태 변경 메서드를 제공하지 않는다.
	* 클래스 확장을 금지한다.
		* final
	* 모든 필드를 final로 선언한다.
	* 모든 필드를 private로 선언한다.
	* 자신 외에는 내부의 가변 컴포넌트에 접근하지 못하게 막는다.
* 함수형 프로그래밍에서는 피연산자를 변경하지 않고, 연산 결과로 새로운 값을 만들어 반환한다. 절차적, 명령형 프로그래밍에서는 피연산자의 상태를 변경한다.
* 불변 객체의 장점
	* 단순하고 쉽다.
	* 스레드 안전하며, 동기화를 할 필요가 없다.
	* 공유가 가능하다.
* 불변 객체는 실패 원자성을 제공한다.
	* 실패 원자성: 메서드에서 예외가 발생했을 때 객체가 메서드 호출 전의 상태를 유지하는 것.
* 불변 객체의 단점
	* 값이 다르면 독립된 객체로 만들어야 한다. 데이터 변경의 시간, 공간 복잡도가 높다.
	* 단점을 해결하는 방법
		* 다단계 연산을 예측하여 기본 기능으로 제공. 각 단계마다 객체가 생성되지 않도록 최적화한다.
		* 가변 클래스를 짝으로 제공한다.
			* 예: String - StringBuilder
* getter를 제공했다고 setter를 제공할 필요는 없다. (당연한 소리!)
* 모든 클래스를 불변으로 만들 수는 없지만, 가변 클래스라도 변경 가능한 부분을 최소화하라.
* 생성자는 불변식 설정이 완료된 상태로 객체를 초기화해야 한다.


## 아이템 18 상속보다는 컴포지션을 사용하라
* 코드 재사용을 위한 수단으로 상속이 언제나 최선은 아니다.
	* 특히 다른 패키지의 구체 클래스를 상속하는 경우는 위험하다.
	* 상속은 캡슐화를 깨트린다. 상위 클래스의 구현에 따라 하위 클래스가 깨질 수 있다.
	* 주로 메서드 확장이 문제가 되므로, 클래스 확장시 메서드를 재정의하지 않으면 덜 위험하다. 하지만 여전히 문제가 생길 가능성이 있다.
		* 예: 하위 클래스에만 있던 메서드를 상위 클래스에서 다른 시그니처로 정의하는 경우
* 구성(composition): private 필드로 다른 클래스의 인스턴스를 참조한다.
* 구성을 이용한 래퍼 클래스에는 단점이 거의 없으나, 콜백 프레임워크와는 어울리지 않는다.
	* SELF 문제: 콜백에서 this가 래퍼가 아닌 내부 객체를 참조하는 문제
* 상속은 상위타입-하위타입 관계(is-a 관계)에서만 사용해야 한다.
* 컴포지션을 사용해야 할 상황에서 상속을 사용하면 내부 구현이 불필요하게 노출된다.
* 핵심 정리:상속은 강력하지만 캡슐화를 해친다는 문제가 있다. 상속은 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때만 써야 한다. is-a 관계일 때도 안심할 수만은 없는 게, 하위 클래스의 패키지가 상위 클래스와 다르고, 상위 클래스가 확장을 고려해 설계되지 않았다면 여전히 문제가 될 수 있다. 상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용하자. 특히 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 더욱 그렇다. 래퍼 클래스는 하위 클래스보다 견고하고 강력하다.


## 아이템 19 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

* 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.
* API 문서의 메서드 설명 끝에 나오는 "Implementation Requirements" 절
		* 메서드의 내부 동작 방식을 설명
		* 메서드 주석에 @implSpec 태그를 붙이면 자바독 도구가 생성
* "좋은 API 문서란 ‘어떻게’가 아닌 ‘무엇’을 하는지를 설명해야 한다"라는 격언과는 대치되지 문제
	* 상속이 캡슐화를 해치기 때문에 일어나는 안타까운 현실이다.
* 상속용 클래스는 배포 전에 반드시 직접 하위 클래스를 만들어 테스트해라.
* 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.
	* 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행된다.
	* 하위 클래스 재정의 메서드가 하위 클래스의 생성자보다 먼저 호출된다.
	* 재정의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면 오류가 발생한다.
* 클래스를 상속용으로 설계하려면 엄청난 노력이 들고 제약도 많다.
* 핵심 정리: 상속용 클래스를 설계하기란 결코 만만치 않다. 클래스 내부에서 스스로를 어떻게 사용하는지(자기사용 패턴) 모두 문서로 남겨야 하며, 일단 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 한다. 그러지 않으면 그 내부 구현 방식을 믿고 활용하던 하위 클래스를 오동작하게 만들 수 있다. 다른 이가 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 할 수도 있다. 그러니 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 나을 것이다. 상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들면 된다.


## 아이템 20 추상 클래스보다는 인터페이스를 우선하라

* 자바는 단일 상속이므로 추상 클래스를 이용하면 새 타입을 정의할 때 제약이 많다.
* 인터페이스의 장점
	* 구현이 쉽다. 기존 클래스에 필요한 메서드를 추가하고 implements 문만 추가하면 된다.
	* 믹스인 정의에 적절하다.
		* 믹스인: 클래스의 주용도 외에 추가 행위를 선택적으로 부여한다고 선언하는 의미
	* 계층구조가 없는 타입 프레임워크를 만들 수 있다.
		* 현실에는 계층을 구별하기 어려운 개념이 많다.
* 디폴트 메서드
	* 인터페이스 메서드 중 구현이 명백한 것은 기본 구현 디폴트 메서드를 제공할 수 있다.
* 템플릿 메서드 패턴
	* 인터페이스와 추상 골격 구현(skeletal implementation) 클래스를 함께 제공하는 방법
	* 인터페이스와 추상 클래스의 장점을 모두 취한다.
	* 작명 관례: 인터페이스 Interface - 골격 구현 클래스 AbstractInterface
	* 골격 구현 클래스 작성 방법
		* 인터페이스를에서 다른 메서드들의 구현에 사용되는 기반 메서드들을 선정한다.
		* 기반 메서드들을 사용해 직접 구현할 수 있는 메서드를 모두 인터페이스의 디폴트 메서드로 제공한다.
		* 기반 메서드나 디폴트 메서드로 만들지 못한 메서드가 남아 있다면, 이 인터페이스를 구현하는 골격 구현 클래스를 하나 만들어 남은 메서드들을 작성해 넣는다.
* 핵심 정리: 일반적으로 다중 구현용 타입으로는 인터페이스가 가장 적합하다. 복잡한 인터페이스라면 구현하는 수고를 덜어주는 골격 구현을 함께 제공하는 방법을 꼭 고려해보자. 골격 구현은 ‘가능한 한’ 인터페이스의 디폴트 메서드로 제공하여 그 인터페이스를 구현한 모든 곳에서 활용하도록 하는 것이 좋다. ‘가능한 한’이라고 한 이유는, 인터페이스에 걸려 있는 구현상의 제약 때문에 골격 구현을 추상 클래스로 제공하는 경우가 더 흔하기 때문이다.


## 아이템 21 인터페이스는 구현하는 쪽을 생각해 설계하라
* 인터페이스에 메서드 추가하기
	* 자바 8 전: 인터페이스에 메서드를 추가하면 기존 구현이 깨진다.
	* 자바 8: 디폴트 메서드가 도입되었지만 위험은 남아 있다.
		* 디폴트 메서드를 선언하면, 디폴트 메서드를 재정의하지 않은 모든 클래스에서 디폴트 구현이 쓰인다.
		* 자바 7까지의 세상에서는 모든 클래스가 "현재의 인터페이스에 새로운 메서드가 추가될 일은 영원히 없다"는 가정에서 구현되었다.
		* 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어렵다.
		* 디폴트 메서드는 컴파일에 성공하더라도 기존 구현체에 런타임 오류를 일으킬 수 있다.
* 디폴트 메서드를 이용하더라도 인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야 한다.

## 아이템 22 인터페이스는 타입을 정의하는 용도로만 사용하라

* 인터페이스는 구현한 클래스의 인스턴스를 참조할 수 있는 타입이다. 인터페이스를 이 용도로만 사용해라.
* 안티패턴: 상수 인터페이스
	* 메서드 없이 statif final 상수 필드로만 채워진 인터페이스
	* 클래스 내부에서 사용하는 상수는 외부 인터페이스가 아니라 내부 구현이다. 상수 인터페이스를 구현하은 내부 구현이 외부에 노출되는 셈이다.
	* 나중에 상수를 쓰지 않도록 변경되더라도 하위 호환을 유지해야 하는 문제가 생긴다.
	* 클래스나 인터페이스와 강하게 연관된 상수라면 그 클래스나 인터페이스 자체에 추가야 한다.
* 핵심 정리: 인터페이스는 타입을 정의하는 용도로만 사용해야 한다. 상수 공개용 수단으로 사용하지 말자.


## 아이템 23 태그 달린 클래스보다는 클래스 계층구조를 활용하라

* 태그 달린 클래스
	* 두 가지 이상의 의미를 표현하고 현재 의미를 태그로 알려주는 방식을 사용하는 클래스
	* 예: `class Figure { enum Shape { RECTANGLE, CIRCLE }; ... }`
* 태그 달린 클래스의 단점
	* 쓸데없는 분기 코드가 많다.
	* 여러 구현이 혼합돼 있어서 가독성이 나쁘다.
	* 안 쓰는 코드를 같이 올려놔야 해서 메모리가 낭비된다.
	* 컴파일러가 타입 검사를 하지 못해 오류를 내기 쉽다.
	* 태그 달린 클래스는 클래스 계층구조를 어설프게 흉내낸 아류일 뿐이다.
* 핵심 정리: 태그 달린 클래스를 써야 하는 상황은 거의 없다. 새로운 클래스를 작성하는 데 태그 필드가 등장한다면 태그를 없애고 계층구조로 대체하는 방법을 생각해보자. 기존 클래스가 태그 필드를 사용하고 있다면 계층구조로 리팩터링하는 걸 고민해보자.


## 아이템 24 멤버 클래스는 되도록 static으로 만들라

* 중첩 클래스(nested class)
	* 다른 클래스 안에 정의된 클래스
	* 자신을 감싼 바깥 클래스에서만 쓰여야 한다. 그렇지 않다면 탑레벨로 보낸다.
* 중첩 클래스의 종류
	* 정적 멤버 클래스
		* 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다. 그 외에는 일반 클래스와 같다.
		* 주용도: 바깥 클래스와 함께 쓰일 때만 유용한 public 도우미 클래스
	* (비정적) 멤버 클래스
		* 비정적 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결된다.
		* 정규화된 this(`클래스명.this`)를 이용해 바깥 인스턴스를 참조할 수 있다.
		* 주용도: 어떤 클래스의 인스턴스를 를 다른 클래스의 인스턴스처럼 보이게 하는 어댑터를 정의할 때
	* 익명 클래스
		* 이름이 없다.
		* 바깥 클래스의 멤버가 아니다.
		* 선언과 동시에 인스턴스가 만들어진다.
		* 상수 변수 이외의 정적 멤버를 갖지 못한다.
		* 주용도: 람다 지원 전에 작은 함수 객체나 프로세스 객체를 만드는 데 주로 쓰였다.
	* 지역 클래스
		* 거의 안 쓰인다.
		* 지역변수를 선언할 수 있는 곳 어디서든 선언할 수 있고, 유효 범위도 지역변수와 같다.
* 핵심 정리: 중첩 클래스에는 네 가지가 있으며, 각각의 쓰임이 다르다. 메서드 밖에서도 사용해야 하거나 메서드 안에 정의하기엔 너무 길다면 멤버 클래스로 만든다. 멤버 클래스의 인스턴스 각각이 바깥 인스턴스를 참조한다면 비정적으로, 그렇지 않으면 정적으로 만들자. 중첩 클래스가 한 메서드 안에서만 쓰이면서 그 인스턴스를 생성하는 지점이 단 한 곳이고 해당 타입으로 쓰기에 적합한 클래스나 인터페이스가 이미 있다면 익명 클래스로 만들고, 그렇지 않으면 지역 클래스로 만들자.


## 아이템 25 톱레벨 클래스는 한 파일에 하나만 담으라
* 소스 파일 하나에 톱레벨 클래스를 여러 개 선언해도 컴파일이 된다. 하지만 그러지 않는 것이 좋다.
* 문제점
	* 아무 이득이 없다.
	* 한 클래스를 여러 가지 파일에서 정의할 수 있으며, 그중 어느 것을 사용할지는 어느 소스 파일을 먼저 컴파일하냐에 따라 달라진다.
* 핵심 정리: 교훈은 명확하다. 소스 파일 하나에는 반드시 톱레벨 클래스(혹은 톱레벨 인터페이스)를 하나만 담자. 이 규칙만 따른다면 컴파일러가 한 클래스에 대한 정의를 여러 개 만들어내는 일은 사라진다. 소스 파일을 어떤 순서로 컴파일하든 바이너리 파일이나 프로그램의 동작이 달라지는 일은 결코 일어나지 않을 것이다.


