# 문서화

**상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.**

- 호출되는 메서드가 재정의 가능 메서드라면 그 사실을 호출하는 메서드의 API 설명에 적시해야 한다.
- 어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지 담아야 한다.
- **재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.**
    - 백그라운드 스레드나 정적 초기화 과정에서도 호출이 일어날 수 있다.

종종 API 문서의 설명 끝에서 ‘Implementation Requiredments’ 로 시작하는 절을 볼 수 있는데, 그 메서드의 내부 동작 방식을 설명하는 곳이다.

→ 메서드 주석에 `@implSpec` 태그를 붙여주면 자바독 도구가 생성해준다.

하지만 위 방식은 “좋은 API 문서는 ‘어떻게' 가 아닌 ‘무엇'을 하는지를 설명해야 한다.” 라는 격언과는 대치되는데 어쩔수 없이 안타까운 부분이다. 클래스를 안전하게 상속할 수 있도록 하려면 내부 구현 방식을 설명해야만 한다.

`@implSpec` 태그는 자바 8에서 처음 도입되었는데 현재는 선택사항이다. (저자는 필수로 바뀌어한다고 생각한다)

# 문서화 외

문서로 남기는 것만이 설계의 전부는 아니다. 

**효율적인 하위 클래스를 어려움 없이 만들 수 있게 하려면 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.**

*(ex) `java.util.AbstractList` 의 removeRange 메서드*

List 구현체의 최종 사용자는 removeRange 메서드에 관심이 없지만 이 메서드를 제공한 이유는 단지 하위 클래스에서 부분리스트의 clear 메서드를 고성능으로 만들기 쉽게 하기 위해서다.

(해당 메서드가 없다면 하위 클래스에서  clear메서드 호출시 성능이 느려지거나 메커니즘을 밑바닥부터 새로 구현해야 했을 것이다.)

## 상속용 클래스 설계 규칙

아래는 상속을 허용하는 클래스가 지켜야 할 제약이다.

### 1. 하위 클래스를 만들어보자

어떤 메서드를 protected로 노출할지 결정할까?

→ 심사숙고하여 잘 예측해보고, 실제로 하위 클래스 만들어 시험해봐야한다. (노오오오오력을 해야한다…)

상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어 보는 것이 ‘유일' 하다. **그러니 무조건 상속용으로 설계한 클래스는 하위 클래스를 만들어 검증하자.**

- 꼭 필요한 protected 멤버를 놓쳤다면 하위 클래스 작성시 빈자리가 확연히 드러나게 되어 추가하면 된다.
- 하위 클래스를 여러개 만들때까지 쓰이지 않은 protected 멤버는 사실 private였어야 할 가능성이 크다.
    - 이런 검증에는 하위 클래스 3개 정도가 적당하고, 하나 이상은 제 3자가 작성해봐야 한다.

### 2. 상속용 클래스의 생성자는 재정의 가능 메서드를 호출해서는 안된다.

상위 클래스의 생성자가 하위클래스의 생성자보다 먼저 실행되므로, 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출된다.

이때 그 재정의한 메서드가 하위 클래스의 생성자에서 초기화 하는 값에 의존하면 의도대로 동작하지 않을 것이다.

### 3. 상속용 클래스가 Cloneable과 Serializable 인터페이스를 사용하게 설계하는 것은 좋지 않다.

해당 클래스를 확장하려는 프로그래머에게 엄청난 부담을 지우기 때문이다.

→ 굳이 구현하도록 하는 특별한 방법이 있는데, 해당 방법은 아이템 13과 86에서 설명한다.

clone과 readObject 메서드는 생성자와 비슷한 효과를 낸다.(새로운 객체를 만든다)

그래서 상속용 클래스에서 해당 인터페이스를 구현할 지 정해야 한다면 이를 구현할 때 따르는 제약도 생성자와 비슷하다.

→ 2번의 규칙이 적용된다. clone 의 경우엔 잘못된다면 원본 객체에 피해를 줄 수 있다.

### 4. Serializabled을 구현한 상속용 클래스가 readResolve나 writeReplace 메서드를 갖는다면 해당 메서드들은 protected로 선언해야한다.

private로 선언하면 하위 클래스에서 무시되기 때문이다.

→ 위에서 얘기한 상속을 허용하기 위해 내부 구현을 클래스 API로 공개하는 예 중 하나다.

# 그래서?

**클래스를 상속용으로 설계하려면 엄청난 노력이 들고 그 클래스에 안기는 제약도 상당하다. 또한 상속용으로 설계하지 않은 클래스는 상속을 금지하자.**

## 상속을 금지시키는 방법

1. 클래스를 final로 선언하는 방법
2. 모든 생성자를 private로 선언하고 public 정적 팩터리를 만들어 주는 방법

상속에 대한 부분은 그동안 많은 프로그래머들이 사용해왔기 때문에 논란이 있다.

**상속용으로 설계하지 않은 클래스를 상속을 꼭 허용해야겠다면 클래스 내부에서 재정의 가능 메서드를 사용하지 않게 만들고 이 사실을 문서로 남기자.**

[**클래스의 동작을 유지하면서 재정의 가능 메서드를 사용하는 코드를 제거할 수 있는 방법]**

1. 각각의 재정의 가능 메서드는 자신의 본문 코드를 private ‘도우미 메서드'로 옮긴다.
2. 해당 도우미 메서드를 호출하도록 수정한다.
3. 재정의 가능 메서드를 호출하는 다른 코드들도 모두 이 도우미 메서드를 직접 호출하도록 수정한다.

# 정리

- 상속용 클래스를 설계할땐 자기사용 패턴을 모두 문서로 남겨야 한다.
- 다른이가 효율 좋은 하위클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 할 수 있으나, 확장해야 할 명확한 이유가 없다면 그냥 상속을 금지시키자.
- 상속을 금지하려면 클래스를 final로 선언하거나, 생성자를 외부에서 접근할 수 없도록 만들면 된다.